package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for WMS_OMS_Profile
 * Generated by CIMTool http://cimtool.org
 */
public class WMS_OMS_Profile
{
    /**
     * Records activity for an entity at a point in time; activity may be for
     * an event that has already occurred or for a planned activity.
     */
    @Entity
    @Table(name="\"ActivityRecord\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ActivityRecord
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time this activity record has been created (different from the
         * 'status.dateTime', which is the time of a status change of the associated
         * object, if applicable).
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Reason for event resulting in this activity record, typically supplied
         * when user initiated.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Severity level of event resulting in this activity record.
         */
        public String getSeverity () { return severity; }
        public void setSeverity ( String severity ) { this.severity = severity; }
        @Basic()
        @Column(name="\"severity\"")
        private String severity ;
         
        /**
         * Type of event resulting in this activity record.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
     
    /**
     * Enumeration for the type of area defined; e.g., county, state, parish,
     * zipcode, etc.
     */
    @Entity
    @Table(name="\"AreaKind\"")
    public static class AreaKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * The parts of the AC power system that are designed to carry current or
     * that are conductively connected through terminals.
     */
    @Entity
    @Table(name="\"ConductingEquipment\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class ConductingEquipment extends Equipment
    {
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Datasheet information for this power system resource.
         */
        public AssetInfo getAssetDatasheet () { return assetDatasheet; }
        public void setAssetDatasheet ( AssetInfo assetDatasheet ) { this.assetDatasheet = assetDatasheet; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AssetDatasheet\"")
        private AssetInfo assetDatasheet ;
         
        /**
         * Dataset containing the data objects.
         */
        public InstanceSet getInstanceSet () { return instanceSet; }
        public void setInstanceSet ( InstanceSet instanceSet ) { this.instanceSet = instanceSet; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"InstanceSet\"")
        private InstanceSet instanceSet ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
        /**
         * The single CIM data object in the appropriate dataset context.
         */
        public ChangeSetMember getPropertiesCIMDataObject () { return propertiesCIMDataObject; }
        public void setPropertiesCIMDataObject ( ChangeSetMember propertiesCIMDataObject ) { this.propertiesCIMDataObject = propertiesCIMDataObject; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PropertiesCIMDataObject\"")
        private ChangeSetMember propertiesCIMDataObject ;
         
        /**
         * Custom classification for this power system resource.
         */
        public PSRType getPSRType () { return pSRType; }
        public void setPSRType ( PSRType pSRType ) { this.pSRType = pSRType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PSRType\"")
        private PSRType pSRType ;
         
    }
    /**
     * Group of people with specific skills, tools, and vehicles.
     */
    @Entity
    @Table(name="\"Crew\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Crew
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Type of this crew.
         */
        public CrewType getCrewType () { return crewType; }
        public void setCrewType ( CrewType crewType ) { this.crewType = crewType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CrewType\"")
        private CrewType crewType ;
         
        /**
         * Status of this crew.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * End date and time of this interval. The end date and time where the interval
     * is defined up to, but excluded.
     */
    public String getEnd () { return end; }
    public void setEnd ( String end ) { this.end = end; }
    @Basic()
    @Column(name="\"end\"")
    private String end ;
     
    /**
     * Start date and time of this interval. The start date and time is included
     * in the defined interval.
     */
    public String getStart () { return start; }
    public void setStart ( String start ) { this.start = start; }
    @Basic()
    @Column(name="\"start\"")
    private String start ;
     
    /**
     * Primary email address.
     */
    public String getEmail1 () { return email1; }
    public void setEmail1 ( String email1 ) { this.email1 = email1; }
    @Basic()
    @Column(name="\"email1\"")
    private String email1 ;
     
    /**
     * The parts of a power system that are physical devices, electronic or mechanical.
     */
    @Entity
    @Table(name="\"Equipment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Equipment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Specifies the availability of the equipment. True means the equipment is
         * available for topology processing, which determines if the equipment is
         * energized or not. False means that the equipment is treated by network
         * applications as if it is not in the model.
         */
        public Boolean getInService () { return inService; }
        public void setInService ( Boolean inService ) { this.inService = inService; }
        @Basic()
        @Column(name="\"inService\"")
        private Boolean inService ;
         
        /**
         * Specifies the availability of the equipment under normal operating conditions.
         * True means the equipment is available for topology processing, which determines
         * if the equipment is energized or not. False means that the equipment is
         * treated by network applications as if it is not in the model.
         */
        public Boolean getNormallyInService () { return normallyInService; }
        public void setNormallyInService ( Boolean normallyInService ) { this.normallyInService = normallyInService; }
        @Basic()
        @Column(name="\"normallyInService\"")
        private Boolean normallyInService ;
         
    }
    /**
     * Abnormal condition causing current flow through conducting equipment, such
     * as caused by equipment failure or short circuits from objects not typically
     * modelled (for example, a tree falling on a line).
     */
    @Entity
    @Table(name="\"Fault\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Fault
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The kind of phase fault.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * The date and time at which the fault occurred.
         */
        public String getOccurredDateTime () { return occurredDateTime; }
        public void setOccurredDateTime ( String occurredDateTime ) { this.occurredDateTime = occurredDateTime; }
        @Basic()
        @Column(name="\"occurredDateTime\"")
        private String occurredDateTime ;
         
        /**
         * The phases participating in the fault. The fault connections into these
         * phases are further specified by the type of fault.
         */
        public PhaseCode getPhases () { return phases; }
        public void setPhases ( PhaseCode phases ) { this.phases = phases; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phases\"")
        private PhaseCode phases ;
         
        /**
         * Equipment carrying this fault.
         */
        public Equipment getFaultyEquipment () { return faultyEquipment; }
        public void setFaultyEquipment ( Equipment faultyEquipment ) { this.faultyEquipment = faultyEquipment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FaultyEquipment\"")
        private Equipment faultyEquipment ;
         
    }
    /**
     * Type of cause of the fault.
     */
    @Entity
    @Table(name="\"FaultCauseType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class FaultCauseType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
    }
    /**
     * The history of field dispatch statuses for this work.
     */
    @Entity
    @Table(name="\"FieldDispatchHistory\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class FieldDispatchHistory
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The crew that has this field dispatch history.
         */
        public Crew getCrew () { return crew; }
        public void setCrew ( Crew crew ) { this.crew = crew; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Crew\"")
        private Crew crew ;
         
        /**
         * The planned outage that has the field dispatch history.
         */
        public PlannedOutage getPlannedOutage () { return plannedOutage; }
        public void setPlannedOutage ( PlannedOutage plannedOutage ) { this.plannedOutage = plannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PlannedOutage\"")
        private PlannedOutage plannedOutage ;
         
        /**
         * The unplanned outage that has the field dispatch history.
         */
        public UnplannedOutage getUnplannedOutage () { return unplannedOutage; }
        public void setUnplannedOutage ( UnplannedOutage unplannedOutage ) { this.unplannedOutage = unplannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"UnplannedOutage\"")
        private UnplannedOutage unplannedOutage ;
         
    }
    /**
     * Description of a problem in the field that may be reported in a trouble
     * ticket or come from another source. It may have to do with an outage.
     */
    @Entity
    @Table(name="\"Incident\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Incident
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Cause of this incident.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic()
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
    }
    /**
     * The Name class provides the means to define any number of human readable
     * names for an object. A name is <b>not</b> to be used for defining inter-object
     * relationships. For inter-object relationships instead use the object identification
     * 'mRID'.
     */
    @Entity
    @Table(name="\"Name\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Name
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Any free text that name the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Identified object that this name designates.
         */
        public IdentifiedObject getIdentifiedObject () { return identifiedObject; }
        public void setIdentifiedObject ( IdentifiedObject identifiedObject ) { this.identifiedObject = identifiedObject; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"IdentifiedObject\"")
        private IdentifiedObject identifiedObject ;
         
        /**
         * Type of this name.
         */
        public NameType getNameType () { return nameType; }
        public void setNameType ( NameType nameType ) { this.nameType = nameType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"NameType\"")
        private NameType nameType ;
         
    }
    /**
     * Type of name. Possible values for attribute 'name' are implementation dependent
     * but standard profiles may specify types. An enterprise may have multiple
     * IT systems each having its own local name for the same object, e.g. a planning
     * system may have different names from an EMS. An object may also have different
     * names within the same IT system, e.g. localName as defined in CIM version
     * 14. The definition from CIM14 is:
     * The localName is a human readable name of the object. It is a free text
     * name local to a node in a naming hierarchy similar to a file directory
     * structure. A power system related naming hierarchy may be: Substation,
     * VoltageLevel, Equipment etc. Children of the same parent in such a hierarchy
     * have names that typically are unique among them.
     */
    @Entity
    @Table(name="\"NameType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class NameType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Document describing details of an active or planned outage in a part of
     * the electrical network.
     * A non-planned outage may be created upon:
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     * A planned outage may be created upon:
     * - a request for service, maintenance or construction work in the field,
     * or
     * - an operator-defined outage for what-if/contingency network analysis.
     */
    @Entity
    @Table(name="\"Outage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Outage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The cause of this outage. This is the cause that is used to present to
         * external entities. That is, the cause is weather, equipment failure, etc.
         * Note: At present, this is a free string text; it could be replaced with
         * an enumeration in the future.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic(optional=true)
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * The possible cause that could be associated with this unplanned outage.
         */
        public OutageCauseKind getCauseKind () { return causeKind; }
        public void setCauseKind ( OutageCauseKind causeKind ) { this.causeKind = causeKind; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"causeKind\"")
        private OutageCauseKind causeKind ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * the total number of customers that are served in the area (both outaged
         * and not outaged).
         */
        public Integer getOriginalCustomersServed () { return originalCustomersServed; }
        public void setOriginalCustomersServed ( Integer originalCustomersServed ) { this.originalCustomersServed = originalCustomersServed; }
        @Basic()
        @Column(name="\"originalCustomersServed\"")
        private Integer originalCustomersServed ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public OutageStatusKind getOutageKind () { return outageKind; }
        public void setOutageKind ( OutageStatusKind outageKind ) { this.outageKind = outageKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"outageKind\"")
        private OutageStatusKind outageKind ;
         
        /**
         * The reason for the planned outage.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic(optional=true)
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * The earliest start time of the Outage - as reported by some system or individual
         */
        public String getReportedStartTime () { return reportedStartTime; }
        public void setReportedStartTime ( String reportedStartTime ) { this.reportedStartTime = reportedStartTime; }
        @Basic(optional=true)
        @Column(name="\"reportedStartTime\"")
        private String reportedStartTime ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public CrewStatusKind getStatusKind () { return statusKind; }
        public void setStatusKind ( CrewStatusKind statusKind ) { this.statusKind = statusKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"statusKind\"")
        private CrewStatusKind statusKind ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Actual outage period; end of the period corresponds to the actual restoration
         * time.
         */
        public DateTimeInterval getActualPeriod () { return actualPeriod; }
        public void setActualPeriod ( DateTimeInterval actualPeriod ) { this.actualPeriod = actualPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"actualPeriod\"")
        private DateTimeInterval actualPeriod ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * Electronic address.
         */
        public ElectronicAddress getElectronicAddress () { return electronicAddress; }
        public void setElectronicAddress ( ElectronicAddress electronicAddress ) { this.electronicAddress = electronicAddress; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"electronicAddress\"")
        private ElectronicAddress electronicAddress ;
         
        /**
         * Estimated outage period for a planned outage. The start of the period is
         * the start of the planned outage and the end of the period corresponds to
         * the end of the planned outage.
         */
        public DateTimeInterval getEstimatedPeriod () { return estimatedPeriod; }
        public void setEstimatedPeriod ( DateTimeInterval estimatedPeriod ) { this.estimatedPeriod = estimatedPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"estimatedPeriod\"")
        private DateTimeInterval estimatedPeriod ;
         
        /**
         * The dispatch history associated with the unplanned outage
         */
        public FieldDispatchHistory getFieldDispatchHistory () { return fieldDispatchHistory; }
        public void setFieldDispatchHistory ( FieldDispatchHistory fieldDispatchHistory ) { this.fieldDispatchHistory = fieldDispatchHistory; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"FieldDispatchHistory\"")
        private FieldDispatchHistory fieldDispatchHistory ;
         
        /**
         * The dispatch history associated with the planned outage
         */
        public FieldDispatchHistory getFieldDispatchHistory () { return fieldDispatchHistory; }
        public void setFieldDispatchHistory ( FieldDispatchHistory fieldDispatchHistory ) { this.fieldDispatchHistory = fieldDispatchHistory; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"FieldDispatchHistory\"")
        private FieldDispatchHistory fieldDispatchHistory ;
         
        /**
         * Outage plan for executing a planned outage.
         */
        public OutagePlan getOutagePlan () { return outagePlan; }
        public void setOutagePlan ( OutagePlan outagePlan ) { this.outagePlan = outagePlan; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"OutagePlan\"")
        private OutagePlan outagePlan ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
        /**
         * Summary counts of service points (customers) affected by this outage.
         */
        public ServicePointOutageSummary getSummary () { return summary; }
        public void setSummary ( ServicePointOutageSummary summary ) { this.summary = summary; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"summary\"")
        private ServicePointOutageSummary summary ;
         
    }
    /**
     * This defines the area covered by the Outage.
     */
    @Entity
    @Table(name="\"OutageArea\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutageArea
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * This is the reported time of the first outage report
         */
        public String getEarliestReportedTime () { return earliestReportedTime; }
        public void setEarliestReportedTime ( String earliestReportedTime ) { this.earliestReportedTime = earliestReportedTime; }
        @Basic()
        @Column(name="\"earliestReportedTime\"")
        private String earliestReportedTime ;
         
        /**
         * defines the number of meters served in the defined area.
         */
        public Integer getMetersServed () { return metersServed; }
        public void setMetersServed ( Integer metersServed ) { this.metersServed = metersServed; }
        @Basic()
        @Column(name="\"metersServed\"")
        private Integer metersServed ;
         
        /**
         * defines the type of area that has the outage - county, state, zipcode,
         * etc.
         */
        public String getOutageAreaKind () { return outageAreaKind; }
        public void setOutageAreaKind ( String outageAreaKind ) { this.outageAreaKind = outageAreaKind; }
        @Basic()
        @Column(name="\"outageAreaKind\"")
        private String outageAreaKind ;
         
    }
    /**
     * Document containing the definition of planned outages of equipment and/or
     * usage points. It will reference switching plans that are used to execute
     * the planned outage.
     */
    @Entity
    @Table(name="\"OutagePlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutagePlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The date and time the outage plan was approved
         */
        public String getApprovedDateTime () { return approvedDateTime; }
        public void setApprovedDateTime ( String approvedDateTime ) { this.approvedDateTime = approvedDateTime; }
        @Basic()
        @Column(name="\"approvedDateTime\"")
        private String approvedDateTime ;
         
        /**
         * Date and Time the planned outage was canceled.
         */
        public String getCancelledDateTime () { return cancelledDateTime; }
        public void setCancelledDateTime ( String cancelledDateTime ) { this.cancelledDateTime = cancelledDateTime; }
        @Basic()
        @Column(name="\"cancelledDateTime\"")
        private String cancelledDateTime ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Purpose of this outage plan, such as whether it is to replace equipment
         * or perform maintenance or repairs or to reconfigure network topology.
         */
        public String getPurpose () { return purpose; }
        public void setPurpose ( String purpose ) { this.purpose = purpose; }
        @Basic()
        @Column(name="\"purpose\"")
        private String purpose ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
    }
     
    /**
     * The type of fault connection among phases.
     */
    @Entity
    @Table(name="\"PhaseConnectedFaultKind\"")
    public static class PhaseConnectedFaultKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     */
    @Entity
    @Table(name="\"PlannedOutage\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PlannedOutage extends Outage
    {
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The reason for the planned outage.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Outage plan for executing a planned outage.
         */
        public OutagePlan getOutagePlan () { return outagePlan; }
        public void setOutagePlan ( OutagePlan outagePlan ) { this.outagePlan = outagePlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OutagePlan\"")
        private OutagePlan outagePlan ;
         
    }
    /**
     * Number of critical service (delivery) points affected by an outage.
     */
    public Integer getCriticalCount () { return criticalCount; }
    public void setCriticalCount ( Integer criticalCount ) { this.criticalCount = criticalCount; }
    @Basic()
    @Column(name="\"criticalCount\"")
    private Integer criticalCount ;
     
    /**
     * Number of all service (delivery) points affected by an outage.
     */
    public Integer getTotalCount () { return totalCount; }
    public void setTotalCount ( Integer totalCount ) { this.totalCount = totalCount; }
    @Basic()
    @Column(name="\"totalCount\"")
    private Integer totalCount ;
     
    /**
     * Date and time for which status 'value' applies.
     */
    public String getDateTime () { return dateTime; }
    public void setDateTime ( String dateTime ) { this.dateTime = dateTime; }
    @Basic()
    @Column(name="\"dateTime\"")
    private String dateTime ;
     
    /**
     * Reason code or explanation for why an object went to the current status
     * 'value'.
     */
    public String getReason () { return reason; }
    public void setReason ( String reason ) { this.reason = reason; }
    @Basic()
    @Column(name="\"reason\"")
    private String reason ;
     
    /**
     * Pertinent information regarding the current 'value', as free form text.
     */
    public String getRemark () { return remark; }
    public void setRemark ( String remark ) { this.remark = remark; }
    @Basic()
    @Column(name="\"remark\"")
    private String remark ;
     
    /**
     * Status value at 'dateTime'; prior status changes may have been kept in
     * instances of activity records associated with the object to which this
     * status applies.
     */
    public String getValue () { return value; }
    public void setValue ( String value ) { this.value = value; }
    @Basic()
    @Column(name="\"value\"")
    private String value ;
     
    /**
     * Action on switch as a switching step.
     */
    @Entity
    @Table(name="\"SwitchAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Actual date and time of this switching step.
         */
        public String getExecutedDateTime () { return executedDateTime; }
        public void setExecutedDateTime ( String executedDateTime ) { this.executedDateTime = executedDateTime; }
        @Basic()
        @Column(name="\"executedDateTime\"")
        private String executedDateTime ;
         
        /**
         * Switching action to perform.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Phases of the Switching Action
         */
        public PhaseCode getPhases () { return phases; }
        public void setPhases ( PhaseCode phases ) { this.phases = phases; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phases\"")
        private PhaseCode phases ;
         
        /**
         * Planned date and time of this switching step.
         */
        public String getPlannedDateTime () { return plannedDateTime; }
        public void setPlannedDateTime ( String plannedDateTime ) { this.plannedDateTime = plannedDateTime; }
        @Basic()
        @Column(name="\"plannedDateTime\"")
        private String plannedDateTime ;
         
    }
     
    /**
     * Kind of action on switch.
     */
    @Entity
    @Table(name="\"SwitchActionKind\"")
    public static class SwitchActionKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A sequence of grouped or atomic steps intended to:
     * - de-energise equipment or part of the network for safe work, and/or
     * - bring back in service previously de-energised equipment or part of the
     * network.
     */
    @Entity
    @Table(name="\"SwitchingPlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingPlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The date and time the switching plan was approved
         */
        public String getApprovedDateTime () { return approvedDateTime; }
        public void setApprovedDateTime ( String approvedDateTime ) { this.approvedDateTime = approvedDateTime; }
        @Basic()
        @Column(name="\"approvedDateTime\"")
        private String approvedDateTime ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * Purpose of this plan, such as whether it is to move the state from normal
         * to some abnormal condition, or to restore the normal state after an abnormal
         * condition, or to perform some kind of optimisation such as correction of
         * overload, voltage control, etc.
         */
        public String getPurpose () { return purpose; }
        public void setPurpose ( String purpose ) { this.purpose = purpose; }
        @Basic()
        @Column(name="\"purpose\"")
        private String purpose ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
    }
    /**
     * Trouble order sends an incident to a crew to initiate a response to an
     * unplanned outage.
     */
    @Entity
    @Table(name="\"TroubleOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free-form comment associated with the trouble order.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Approver of this document.
         */
        public Approver getApprover () { return approver; }
        public void setApprover ( Approver approver ) { this.approver = approver; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Approver\"")
        private Approver approver ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * The planned start and end time for the trouble order.
         */
        public DateTimeInterval getPlannedExecutionInterval () { return plannedExecutionInterval; }
        public void setPlannedExecutionInterval ( DateTimeInterval plannedExecutionInterval ) { this.plannedExecutionInterval = plannedExecutionInterval; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"plannedExecutionInterval\"")
        private DateTimeInterval plannedExecutionInterval ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
     
    /**
     * Kind of trouble reporting.
     */
    @Entity
    @Table(name="\"TroubleReportingKind\"")
    public static class TroubleReportingKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     */
    @Entity
    @Table(name="\"TroubleTicket\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleTicket
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free-form comment associated with the trouble call for example, "customer
         * reported a large flash", etc.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time the trouble has been reported.
         */
        public String getDateTimeOfReport () { return dateTimeOfReport; }
        public void setDateTimeOfReport ( String dateTimeOfReport ) { this.dateTimeOfReport = dateTimeOfReport; }
        @Basic()
        @Column(name="\"dateTimeOfReport\"")
        private String dateTimeOfReport ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Indicates whether the first responder such as police, fire department etc.has
         * been notified and whether they are on site or en route.
         */
        public String getFirstResponderStatus () { return firstResponderStatus; }
        public void setFirstResponderStatus ( String firstResponderStatus ) { this.firstResponderStatus = firstResponderStatus; }
        @Basic()
        @Column(name="\"firstResponderStatus\"")
        private String firstResponderStatus ;
         
        /**
         * Set to true if the outage report indicated that other neighbors are also
         * out of power.
         */
        public Boolean getMultiplePremises () { return multiplePremises; }
        public void setMultiplePremises ( Boolean multiplePremises ) { this.multiplePremises = multiplePremises; }
        @Basic()
        @Column(name="\"multiplePremises\"")
        private Boolean multiplePremises ;
         
        /**
         * Indicates how the customer reported trouble.
         */
        public String getReportingKind () { return reportingKind; }
        public void setReportingKind ( String reportingKind ) { this.reportingKind = reportingKind; }
        @Basic()
        @Column(name="\"reportingKind\"")
        private String reportingKind ;
         
        /**
         * Date and time this trouble ticket has been resolved.
         */
        public String getResolvedDateTime () { return resolvedDateTime; }
        public void setResolvedDateTime ( String resolvedDateTime ) { this.resolvedDateTime = resolvedDateTime; }
        @Basic()
        @Column(name="\"resolvedDateTime\"")
        private String resolvedDateTime ;
         
        /**
         * Trouble code (e.g., power down, flickering lights, partial power, etc).
         */
        public String getTroubleCode () { return troubleCode; }
        public void setTroubleCode ( String troubleCode ) { this.troubleCode = troubleCode; }
        @Basic()
        @Column(name="\"troubleCode\"")
        private String troubleCode ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * Logical or physical point in the network to which readings or events may
     * be attributed. Used at the place where a physical or virtual meter may
     * be located; however, it is not required that a meter be present.
     */
    @Entity
    @Table(name="\"UsagePoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class UsagePoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Estimated load.
         */
        public Double getEstimatedLoad () { return estimatedLoad; }
        public void setEstimatedLoad ( Double estimatedLoad ) { this.estimatedLoad = estimatedLoad; }
        @Basic()
        @Column(name="\"estimatedLoad\"")
        private Double estimatedLoad ;
         
        /**
         * Phase code. Number of wires and specific nominal phases can be deduced
         * from enumeration literal values. For example, ABCN is three-phase, four-wire,
         * s12n (splitSecondary12N) is single-phase, three-wire, and s1n and s2n are
         * single-phase, two-wire.
         */
        public PhaseCode getPhaseCode () { return phaseCode; }
        public void setPhaseCode ( PhaseCode phaseCode ) { this.phaseCode = phaseCode; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phaseCode\"")
        private PhaseCode phaseCode ;
         
        /**
         * Current flow that this usage point is configured to deliver.
         */
        public Double getRatedCurrent () { return ratedCurrent; }
        public void setRatedCurrent ( Double ratedCurrent ) { this.ratedCurrent = ratedCurrent; }
        @Basic()
        @Column(name="\"ratedCurrent\"")
        private Double ratedCurrent ;
         
        /**
         * Active power that this usage point is configured to deliver.
         */
        public Double getRatedPower () { return ratedPower; }
        public void setRatedPower ( Double ratedPower ) { this.ratedPower = ratedPower; }
        @Basic()
        @Column(name="\"ratedPower\"")
        private Double ratedPower ;
         
    }
    /**
     * Verification of a switch position or other condition as a switching step
     */
    @Entity
    @Table(name="\"VerificationAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class VerificationAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Actual date and time of this switching step.
         */
        public String getExecutedDateTime () { return executedDateTime; }
        public void setExecutedDateTime ( String executedDateTime ) { this.executedDateTime = executedDateTime; }
        @Basic()
        @Column(name="\"executedDateTime\"")
        private String executedDateTime ;
         
        /**
         * Phases of the Switching Action
         */
        public PhaseCode getPhases () { return phases; }
        public void setPhases ( PhaseCode phases ) { this.phases = phases; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phases\"")
        private PhaseCode phases ;
         
        /**
         * freeform description of the condition to be verified
         */
        public String getVerificationCondition () { return verificationCondition; }
        public void setVerificationCondition ( String verificationCondition ) { this.verificationCondition = verificationCondition; }
        @Basic()
        @Column(name="\"verificationCondition\"")
        private String verificationCondition ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        ActivityRecord.class,
        AreaKind.class,
        ConductingEquipment.class,
        Crew.class,
        Equipment.class,
        Fault.class,
        FaultCauseType.class,
        FieldDispatchHistory.class,
        Incident.class,
        Name.class,
        NameType.class,
        Outage.class,
        OutageArea.class,
        OutagePlan.class,
        PhaseConnectedFaultKind.class,
        PlannedOutage.class,
        SwitchAction.class,
        SwitchActionKind.class,
        SwitchingPlan.class,
        TroubleOrder.class,
        TroubleReportingKind.class,
        TroubleTicket.class,
        UsagePoint.class,
        VerificationAction.class
    };
}
