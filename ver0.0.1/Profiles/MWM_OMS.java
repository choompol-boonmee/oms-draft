package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for MWM_OMS_Profile
 * Generated by CIMTool http://cimtool.org
 */
public class MWM_OMS_Profile
{
    /**
     * Meeting time and location.
     */
    @Entity
    @Table(name="\"Appointment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Appointment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * True if requested to call customer when someone is about to arrive at their
         * premises.
         */
        public Boolean getCallAhead () { return callAhead; }
        public void setCallAhead ( Boolean callAhead ) { this.callAhead = callAhead; }
        @Basic()
        @Column(name="\"callAhead\"")
        private Boolean callAhead ;
         
        /**
         * Date and time reserved for appointment.
         */
        public DateTimeInterval getMeetingInterval () { return meetingInterval; }
        public void setMeetingInterval ( DateTimeInterval meetingInterval ) { this.meetingInterval = meetingInterval; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"meetingInterval\"")
        private DateTimeInterval meetingInterval ;
         
    }
    /**
     * Group of people with specific skills, tools, and vehicles.
     */
    @Entity
    @Table(name="\"Crew\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Crew
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Type of this crew.
         */
        public CrewType getCrewType () { return crewType; }
        public void setCrewType ( CrewType crewType ) { this.crewType = crewType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CrewType\"")
        private CrewType crewType ;
         
        /**
         * The location this crew is assigned to.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
        /**
         * Status of this crew.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
        /**
         * The switching action that is assigned to this crew.
         */
        public SwitchingAction getSwitchingAction () { return switchingAction; }
        public void setSwitchingAction ( SwitchingAction switchingAction ) { this.switchingAction = switchingAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchingAction\"")
        private SwitchingAction switchingAction ;
         
    }
    /**
     * Member of a crew.
     */
    @Entity
    @Table(name="\"CrewMember\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CrewMember
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
     
    /**
     * Defines the current status of the Crew - assigned, arrived, etc.
     */
    @Entity
    @Table(name="\"CrewStatusKind\"")
    public static class CrewStatusKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * End date and time of this interval. The end date and time where the interval
     * is defined up to, but excluded.
     */
    public String getEnd () { return end; }
    public void setEnd ( String end ) { this.end = end; }
    @Basic()
    @Column(name="\"end\"")
    private String end ;
     
    /**
     * Start date and time of this interval. The start date and time is included
     * in the defined interval.
     */
    public String getStart () { return start; }
    public void setStart ( String start ) { this.start = start; }
    @Basic()
    @Column(name="\"start\"")
    private String start ;
     
     
    /**
     * The estimated restoration time (ERT) is the amount of time estimated to
     * correct the outage and can have a confidence factor applied such as high
     * or low confidence that the ERT will be accomplished. This confidence factor
     * may be updated as needed during the outage period - just as the actual
     * ERT can be updated.
     */
    @Entity
    @Table(name="\"ERTConfidenceKind\"")
    public static class ERTConfidenceKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Asset container that performs one or more end device functions. One type
     * of end device is a meter which can perform metering, load management, connect/disconnect,
     * accounting functions, etc. Some end devices, such as ones monitoring and
     * controlling air conditioners, refrigerators, pool pumps may be connected
     * to a meter. All end devices may have communication capability defined by
     * the associated communication function(s). An end device may be owned by
     * a consumer, a service provider, utility or otherwise.
     * There may be a related end device function that identifies a sensor or
     * control point within a metering application or communications systems (e.g.,
     * water, gas, electricity).
     * Some devices may use an optical port that conforms to the ANSI C12.18 standard
     * for communications.
     */
    @Entity
    @Table(name="\"EndDevice\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EndDevice
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * The parts of a power system that are physical devices, electronic or mechanical.
     */
    @Entity
    @Table(name="\"Equipment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Equipment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * The Estimated Restoration Time (ERT) for a single outage
     */
    @Entity
    @Table(name="\"EstimatedRestorationTime\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EstimatedRestorationTime
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * provides the confidence level that this ERT can be accomplished. This may
         * be changed/updated as needed.
         */
        public String getConfidenceKind () { return confidenceKind; }
        public void setConfidenceKind ( String confidenceKind ) { this.confidenceKind = confidenceKind; }
        @Basic()
        @Column(name="\"confidenceKind\"")
        private String confidenceKind ;
         
        /**
         * estimated time the outage will be restored
         */
        public String getErt () { return ert; }
        public void setErt ( String ert ) { this.ert = ert; }
        @Basic()
        @Column(name="\"ert\"")
        private String ert ;
         
        /**
         * defines the source that provided the ERT value.
         */
        public String getErtSource () { return ertSource; }
        public void setErtSource ( String ertSource ) { this.ertSource = ertSource; }
        @Basic()
        @Column(name="\"ertSource\"")
        private String ertSource ;
         
    }
    /**
     * Description of a problem in the field that may be reported in a trouble
     * ticket or come from another source. It may have to do with an outage.
     */
    @Entity
    @Table(name="\"Incident\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Incident
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Cause of this incident.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic()
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * The place, scene, or point of something where someone or something has
     * been, is, and/or will be at a given moment in time. It can be defined with
     * one or more position points (coordinates) in a given coordinate system.
     */
    @Entity
    @Table(name="\"Location\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Location
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * (if applicable) Direction that allows field crews to quickly find a given
         * asset. For a given location, such as a street address, this is the relative
         * direction in which to find the asset. For example, a streetlight may be
         * located at the 'NW' (northwest) corner of the customer's site, or a usage
         * point may be located on the second floor of an apartment building.
         */
        public String getDirection () { return direction; }
        public void setDirection ( String direction ) { this.direction = direction; }
        @Basic()
        @Column(name="\"direction\"")
        private String direction ;
         
        /**
         * (if applicable) Reference to geographical information source, often external
         * to the utility.
         */
        public String getGeoInfoReference () { return geoInfoReference; }
        public void setGeoInfoReference ( String geoInfoReference ) { this.geoInfoReference = geoInfoReference; }
        @Basic()
        @Column(name="\"geoInfoReference\"")
        private String geoInfoReference ;
         
        /**
         * Classification by utility's corporate standards and practices, relative
         * to the location itself (e.g., geographical, functional accounting, etc.,
         * not a given property that happens to exist at that location).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Coordinate system used to describe position points of this location.
         */
        public CoordinateSystem getCoordinateSystem () { return coordinateSystem; }
        public void setCoordinateSystem ( CoordinateSystem coordinateSystem ) { this.coordinateSystem = coordinateSystem; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CoordinateSystem\"")
        private CoordinateSystem coordinateSystem ;
         
    }
    /**
     * Document describing details of an active or planned outage in a part of
     * the electrical network.
     * A non-planned outage may be created upon:
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     * A planned outage may be created upon:
     * - a request for service, maintenance or construction work in the field,
     * or
     * - an operator-defined outage for what-if/contingency network analysis.
     */
    @Entity
    @Table(name="\"Outage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Outage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * a name to denote the community - this could be a name or a code of some
         * kind.
         */
        public String getCommunityDescriptor () { return communityDescriptor; }
        public void setCommunityDescriptor ( String communityDescriptor ) { this.communityDescriptor = communityDescriptor; }
        @Basic()
        @Column(name="\"communityDescriptor\"")
        private String communityDescriptor ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * the total number of customers that are served in the area (both outaged
         * and not outaged).
         */
        public Integer getOriginalCustomersServed () { return originalCustomersServed; }
        public void setOriginalCustomersServed ( Integer originalCustomersServed ) { this.originalCustomersServed = originalCustomersServed; }
        @Basic()
        @Column(name="\"originalCustomersServed\"")
        private Integer originalCustomersServed ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public String getOutageKind () { return outageKind; }
        public void setOutageKind ( String outageKind ) { this.outageKind = outageKind; }
        @Basic()
        @Column(name="\"outageKind\"")
        private String outageKind ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public String getStatusKind () { return statusKind; }
        public void setStatusKind ( String statusKind ) { this.statusKind = statusKind; }
        @Basic()
        @Column(name="\"statusKind\"")
        private String statusKind ;
         
        /**
         * This contains an disclaimers the utility would like to place on the data
         * provided to any stakeholder. This may be different for different stakeholders.
         * This should possibly be an attribute under the Organization class but it
         * is placed here for now.
         */
        public String getUtilityDisclaimer () { return utilityDisclaimer; }
        public void setUtilityDisclaimer ( String utilityDisclaimer ) { this.utilityDisclaimer = utilityDisclaimer; }
        @Basic()
        @Column(name="\"utilityDisclaimer\"")
        private String utilityDisclaimer ;
         
        /**
         * The estimated time that the power will be restored after an outage
         */
        public EstimatedRestorationTime getEstimatedRestorationTime () { return estimatedRestorationTime; }
        public void setEstimatedRestorationTime ( EstimatedRestorationTime estimatedRestorationTime ) { this.estimatedRestorationTime = estimatedRestorationTime; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EstimatedRestorationTime\"")
        private EstimatedRestorationTime estimatedRestorationTime ;
         
    }
    /**
     * Transmits an outage plan to a crew in order for the planned outage to be
     * executed.
     */
    @Entity
    @Table(name="\"OutageOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutageOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * Free-form comment associated with the outage order
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * The outage plan that is defined to address the outage order.
         */
        public OutagePlan getOutagePlan () { return outagePlan; }
        public void setOutagePlan ( OutagePlan outagePlan ) { this.outagePlan = outagePlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OutagePlan\"")
        private OutagePlan outagePlan ;
         
    }
    /**
     * Document containing the definition of planned outages of equipment and/or
     * usage points. It will reference switching plans that are used to execute
     * the planned outage.
     */
    @Entity
    @Table(name="\"OutagePlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutagePlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The outage order that will address the outage plan.
         */
        public OutageOrder getOutageOrder () { return outageOrder; }
        public void setOutageOrder ( OutageOrder outageOrder ) { this.outageOrder = outageOrder; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OutageOrder\"")
        private OutageOrder outageOrder ;
         
        /**
         * The outage resulting from the execution of the outage plan.
         */
        public PlannedOutage getPlannedOutage () { return plannedOutage; }
        public void setPlannedOutage ( PlannedOutage plannedOutage ) { this.plannedOutage = plannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PlannedOutage\"")
        private PlannedOutage plannedOutage ;
         
        /**
         * The swiching plan that is associated with the outage plan.
         */
        public SwitchingPlan getSwitchingPlan () { return switchingPlan; }
        public void setSwitchingPlan ( SwitchingPlan switchingPlan ) { this.switchingPlan = switchingPlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchingPlan\"")
        private SwitchingPlan switchingPlan ;
         
    }
     
    /**
     * This defines if the outage have been predicted or confirmed
     */
    @Entity
    @Table(name="\"OutageStatusKind\"")
    public static class OutageStatusKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * General purpose information for name and other information to contact people.
     */
    @Entity
    @Table(name="\"Person\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Person
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Middle name(s) or initial(s).
         */
        public String getMName () { return mName; }
        public void setMName ( String mName ) { this.mName = mName; }
        @Basic()
        @Column(name="\"mName\"")
        private String mName ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Electronic address.
         */
        public ElectronicAddress getElectronicAddress () { return electronicAddress; }
        public void setElectronicAddress ( ElectronicAddress electronicAddress ) { this.electronicAddress = electronicAddress; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"electronicAddress\"")
        private ElectronicAddress electronicAddress ;
         
        /**
         * Landline phone number.
         */
        public TelephoneNumber getLandlinePhone () { return landlinePhone; }
        public void setLandlinePhone ( TelephoneNumber landlinePhone ) { this.landlinePhone = landlinePhone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"landlinePhone\"")
        private TelephoneNumber landlinePhone ;
         
        /**
         * Mobile phone number.
         */
        public TelephoneNumber getMobilePhone () { return mobilePhone; }
        public void setMobilePhone ( TelephoneNumber mobilePhone ) { this.mobilePhone = mobilePhone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"mobilePhone\"")
        private TelephoneNumber mobilePhone ;
         
    }
    /**
     */
    @Entity
    @Table(name="\"PersonRole\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PersonRole
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
    /**
     * Set of spatial coordinates that determine a point, defined in the coordinate
     * system specified in 'Location.CoordinateSystem'. Use a single position
     * point instance to describe a point-oriented location. Use a sequence of
     * position points to describe a line-oriented object (physical location of
     * non-point oriented objects like cables or lines), or area of an object
     * (like a substation or a geographical zone - in this case, have first and
     * last position point with the same values).
     */
    @Entity
    @Table(name="\"PositionPoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PositionPoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Zero-relative sequence number of this point within a series of points.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
        /**
         * X axis position.
         */
        public String getXPosition () { return xPosition; }
        public void setXPosition ( String xPosition ) { this.xPosition = xPosition; }
        @Basic()
        @Column(name="\"xPosition\"")
        private String xPosition ;
         
        /**
         * Y axis position.
         */
        public String getYPosition () { return yPosition; }
        public void setYPosition ( String yPosition ) { this.yPosition = yPosition; }
        @Basic()
        @Column(name="\"yPosition\"")
        private String yPosition ;
         
    }
    /**
     * Date and time for which status 'value' applies.
     */
    public String getDateTime () { return dateTime; }
    public void setDateTime ( String dateTime ) { this.dateTime = dateTime; }
    @Basic()
    @Column(name="\"dateTime\"")
    private String dateTime ;
     
    /**
     * Reason code or explanation for why an object went to the current status
     * 'value'.
     */
    public String getReason () { return reason; }
    public void setReason ( String reason ) { this.reason = reason; }
    @Basic()
    @Column(name="\"reason\"")
    private String reason ;
     
    /**
     * Pertinent information regarding the current 'value', as free form text.
     */
    public String getRemark () { return remark; }
    public void setRemark ( String remark ) { this.remark = remark; }
    @Basic()
    @Column(name="\"remark\"")
    private String remark ;
     
    /**
     * Status value at 'dateTime'; prior status changes may have been kept in
     * instances of activity records associated with the object to which this
     * status applies.
     */
    public String getValue () { return value; }
    public void setValue ( String value ) { this.value = value; }
    @Basic()
    @Column(name="\"value\"")
    private String value ;
     
    /**
     * Trouble order sends an incident to a crew to initiate a response to an
     * unplanned outage.
     */
    @Entity
    @Table(name="\"TroubleOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * Free-form comment associated with the trouble order.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * The incident that may be associated with the trouble order.
         */
        public Incident getIncident () { return incident; }
        public void setIncident ( Incident incident ) { this.incident = incident; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Incident\"")
        private Incident incident ;
         
        /**
         * The location of this trouble order
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
        /**
         * The unplanned outage that is associated to the Trouble Order.
         */
        public UnplannedOutage getUnplannedOutage () { return unplannedOutage; }
        public void setUnplannedOutage ( UnplannedOutage unplannedOutage ) { this.unplannedOutage = unplannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"UnplannedOutage\"")
        private UnplannedOutage unplannedOutage ;
         
    }
     
    /**
     * Kind of trouble reporting.
     */
    @Entity
    @Table(name="\"TroubleReportingKind\"")
    public static class TroubleReportingKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     */
    @Entity
    @Table(name="\"TroubleTicket\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleTicket
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Free-form comment associated with the trouble call for example, "customer
         * reported a large flash", etc.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Date and time the trouble has been reported.
         */
        public String getDateTimeOfReport () { return dateTimeOfReport; }
        public void setDateTimeOfReport ( String dateTimeOfReport ) { this.dateTimeOfReport = dateTimeOfReport; }
        @Basic()
        @Column(name="\"dateTimeOfReport\"")
        private String dateTimeOfReport ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Indicates whether the first responder such as police, fire department etc.has
         * been notified and whether they are on site or en route.
         */
        public String getFirstResponderStatus () { return firstResponderStatus; }
        public void setFirstResponderStatus ( String firstResponderStatus ) { this.firstResponderStatus = firstResponderStatus; }
        @Basic()
        @Column(name="\"firstResponderStatus\"")
        private String firstResponderStatus ;
         
        /**
         * Set to true if the outage report indicated that other neighbors are also
         * out of power.
         */
        public Boolean getMultiplePremises () { return multiplePremises; }
        public void setMultiplePremises ( Boolean multiplePremises ) { this.multiplePremises = multiplePremises; }
        @Basic()
        @Column(name="\"multiplePremises\"")
        private Boolean multiplePremises ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Indicates how the customer reported trouble.
         */
        public String getReportingKind () { return reportingKind; }
        public void setReportingKind ( String reportingKind ) { this.reportingKind = reportingKind; }
        @Basic()
        @Column(name="\"reportingKind\"")
        private String reportingKind ;
         
        /**
         * Date and time this trouble ticket has been resolved.
         */
        public String getResolvedDateTime () { return resolvedDateTime; }
        public void setResolvedDateTime ( String resolvedDateTime ) { this.resolvedDateTime = resolvedDateTime; }
        @Basic()
        @Column(name="\"resolvedDateTime\"")
        private String resolvedDateTime ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Trouble code (e.g., power down, flickering lights, partial power, etc).
         */
        public String getTroubleCode () { return troubleCode; }
        public void setTroubleCode ( String troubleCode ) { this.troubleCode = troubleCode; }
        @Basic()
        @Column(name="\"troubleCode\"")
        private String troubleCode ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * Logical or physical point in the network to which readings or events may
     * be attributed. Used at the place where a physical or virtual meter may
     * be located; however, it is not required that a meter be present.
     */
    @Entity
    @Table(name="\"UsagePoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class UsagePoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * Document used to request, initiate, track and record work.
     */
    @Entity
    @Table(name="\"Work\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Work
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time work was requested.
         */
        public String getRequestDateTime () { return requestDateTime; }
        public void setRequestDateTime ( String requestDateTime ) { this.requestDateTime = requestDateTime; }
        @Basic()
        @Column(name="\"requestDateTime\"")
        private String requestDateTime ;
         
        /**
         * Work order number (or other unique identifying information) for this work.
         */
        public String getWorkOrderNumber () { return workOrderNumber; }
        public void setWorkOrderNumber ( String workOrderNumber ) { this.workOrderNumber = workOrderNumber; }
        @Basic()
        @Column(name="\"workOrderNumber\"")
        private String workOrderNumber ;
         
        /**
         */
        public WorkBillingInfo getWorkBillingInfo () { return workBillingInfo; }
        public void setWorkBillingInfo ( WorkBillingInfo workBillingInfo ) { this.workBillingInfo = workBillingInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WorkBillingInfo\"")
        private WorkBillingInfo workBillingInfo ;
         
    }
    /**
     * Billing information for work performed for the customer. The history of
     * Work Billing Info, Invoices, and Payments is to be maintained in associated
     * ActivityRecords.
     */
    @Entity
    @Table(name="\"WorkBillingInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WorkBillingInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Estimated cost for work.
         */
        public String getCostEstimate () { return costEstimate; }
        public void setCostEstimate ( String costEstimate ) { this.costEstimate = costEstimate; }
        @Basic()
        @Column(name="\"costEstimate\"")
        private String costEstimate ;
         
        /**
         * Amount of price on deposit.
         */
        public String getDeposit () { return deposit; }
        public void setDeposit ( String deposit ) { this.deposit = deposit; }
        @Basic()
        @Column(name="\"deposit\"")
        private String deposit ;
         
        /**
         * Discount from standard price.
         */
        public Double getDiscount () { return discount; }
        public void setDiscount ( Double discount ) { this.discount = discount; }
        @Basic()
        @Column(name="\"discount\"")
        private Double discount ;
         
        /**
         * Date and time by which payment for bill is expected from client.
         */
        public String getDueDateTime () { return dueDateTime; }
        public void setDueDateTime ( String dueDateTime ) { this.dueDateTime = dueDateTime; }
        @Basic()
        @Column(name="\"dueDateTime\"")
        private String dueDateTime ;
         
        /**
         * Date and time bill was issued to client.
         */
        public String getIssueDateTime () { return issueDateTime; }
        public void setIssueDateTime ( String issueDateTime ) { this.issueDateTime = issueDateTime; }
        @Basic()
        @Column(name="\"issueDateTime\"")
        private String issueDateTime ;
         
        /**
         * Date payment was received from client.
         */
        public String getReceivedDateTime () { return receivedDateTime; }
        public void setReceivedDateTime ( String receivedDateTime ) { this.receivedDateTime = receivedDateTime; }
        @Basic()
        @Column(name="\"receivedDateTime\"")
        private String receivedDateTime ;
         
        /**
         * Amount of bill.
         */
        public String getWorkPrice () { return workPrice; }
        public void setWorkPrice ( String workPrice ) { this.workPrice = workPrice; }
        @Basic()
        @Column(name="\"workPrice\"")
        private String workPrice ;
         
    }
    /**
     * A task within a set of work.
     */
    @Entity
    @Table(name="\"WorkTask\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WorkTask
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time work task was completed.
         */
        public String getCompletedDateTime () { return completedDateTime; }
        public void setCompletedDateTime ( String completedDateTime ) { this.completedDateTime = completedDateTime; }
        @Basic()
        @Column(name="\"completedDateTime\"")
        private String completedDateTime ;
         
        /**
         * Total contractor costs associated with the work task.
         */
        public String getContractorCost () { return contractorCost; }
        public void setContractorCost ( String contractorCost ) { this.contractorCost = contractorCost; }
        @Basic()
        @Column(name="\"contractorCost\"")
        private String contractorCost ;
         
        /**
         * Time and Date when the work task will be completed.
         */
        public String getEstimatedCompletionTime () { return estimatedCompletionTime; }
        public void setEstimatedCompletionTime ( String estimatedCompletionTime ) { this.estimatedCompletionTime = estimatedCompletionTime; }
        @Basic()
        @Column(name="\"estimatedCompletionTime\"")
        private String estimatedCompletionTime ;
         
        /**
         * Instructions for performing this task.
         */
        public String getInstruction () { return instruction; }
        public void setInstruction ( String instruction ) { this.instruction = instruction; }
        @Basic()
        @Column(name="\"instruction\"")
        private String instruction ;
         
        /**
         * Total labor costs associated with the work task.
         */
        public String getLaborCost () { return laborCost; }
        public void setLaborCost ( String laborCost ) { this.laborCost = laborCost; }
        @Basic()
        @Column(name="\"laborCost\"")
        private String laborCost ;
         
        /**
         * Hours of labor expended under work task.
         */
        public Double getLaborHours () { return laborHours; }
        public void setLaborHours ( Double laborHours ) { this.laborHours = laborHours; }
        @Basic()
        @Column(name="\"laborHours\"")
        private Double laborHours ;
         
        /**
         * Total material costs associated with the work task.
         */
        public String getMateriallCost () { return materiallCost; }
        public void setMateriallCost ( String materiallCost ) { this.materiallCost = materiallCost; }
        @Basic()
        @Column(name="\"materiallCost\"")
        private String materiallCost ;
         
        /**
         * If specified, override schedule and perform this task in accordance with
         * instructions specified here.
         */
        public String getSchedOverride () { return schedOverride; }
        public void setSchedOverride ( String schedOverride ) { this.schedOverride = schedOverride; }
        @Basic()
        @Column(name="\"schedOverride\"")
        private String schedOverride ;
         
        /**
         * Date and time work task was started.
         */
        public String getStartedDateTime () { return startedDateTime; }
        public void setStartedDateTime ( String startedDateTime ) { this.startedDateTime = startedDateTime; }
        @Basic()
        @Column(name="\"startedDateTime\"")
        private String startedDateTime ;
         
        /**
         * Kind of work.
         */
        public String getTaskKind () { return taskKind; }
        public void setTaskKind ( String taskKind ) { this.taskKind = taskKind; }
        @Basic()
        @Column(name="\"taskKind\"")
        private String taskKind ;
         
        /**
         * Total tool costs associated with the work task.
         */
        public String getToolCost () { return toolCost; }
        public void setToolCost ( String toolCost ) { this.toolCost = toolCost; }
        @Basic()
        @Column(name="\"toolCost\"")
        private String toolCost ;
         
    }
     
    /**
     * Kinds of work tasks.
     */
    @Entity
    @Table(name="\"WorkTaskKind\"")
    public static class WorkTaskKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    public static final Class[] allClasses = new Class[]
    {
        Appointment.class,
        Crew.class,
        CrewMember.class,
        CrewStatusKind.class,
        ERTConfidenceKind.class,
        EndDevice.class,
        Equipment.class,
        EstimatedRestorationTime.class,
        Incident.class,
        Location.class,
        Outage.class,
        OutageOrder.class,
        OutagePlan.class,
        OutageStatusKind.class,
        Person.class,
        PersonRole.class,
        PositionPoint.class,
        TroubleOrder.class,
        TroubleReportingKind.class,
        TroubleTicket.class,
        UsagePoint.class,
        Work.class,
        WorkBillingInfo.class,
        WorkTask.class,
        WorkTaskKind.class
    };
}
