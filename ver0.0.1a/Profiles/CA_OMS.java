package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for CA-OMS-Profile
 * Generated by CIMTool http://cimtool.org
 */
public class CA-OMS-Profile
{
    /**
     * Notifications for move-in, move-out, delinquencies, etc.
     */
    @Entity
    @Table(name="\"AccountNotification\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AccountNotification
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Notifications for move-in, move-out, delinquencies, planned outage, demand
         * response programs, time of use, etc.
         */
        public String getCustomerNotificationType () { return customerNotificationType; }
        public void setCustomerNotificationType ( String customerNotificationType ) { this.customerNotificationType = customerNotificationType; }
        @Basic()
        @Column(name="\"customerNotificationType\"")
        private String customerNotificationType ;
         
        /**
         * method of notification such as phone call, email, letter, door hanger,
         * text message, etc.
         */
        public String getMethodType () { return methodType; }
        public void setMethodType ( String methodType ) { this.methodType = methodType; }
        @Basic()
        @Column(name="\"methodType\"")
        private String methodType ;
         
        /**
         * Free form text characterizing the notification.
         */
        public String getNote () { return note; }
        public void setNote ( String note ) { this.note = note; }
        @Basic()
        @Column(name="\"note\"")
        private String note ;
         
        /**
         * Time of notification - this is the time the notification was sent.
         */
        public String getTime () { return time; }
        public void setTime ( String time ) { this.time = time; }
        @Basic()
        @Column(name="\"time\"")
        private String time ;
         
        /**
         * The customer account for which a notification is made
         */
        public CustomerAccount getCustomerAccount () { return customerAccount; }
        public void setCustomerAccount ( CustomerAccount customerAccount ) { this.customerAccount = customerAccount; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CustomerAccount\"")
        private CustomerAccount customerAccount ;
         
    }
     
    /**
     * Kind of bill media.
     */
    @Entity
    @Table(name="\"BillMediaKind\"")
    public static class BillMediaKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Organisation receiving services from service supplier.
     */
    @Entity
    @Table(name="\"Customer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Customer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Kind of customer.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Locale designating language to use in communications with this customer.
         */
        public String getLocale () { return locale; }
        public void setLocale ( String locale ) { this.locale = locale; }
        @Basic()
        @Column(name="\"locale\"")
        private String locale ;
         
        /**
         * True if customer organisation has special service needs such as life support,
         * hospitals, etc.
         */
        public String getSpecialNeed () { return specialNeed; }
        public void setSpecialNeed ( String specialNeed ) { this.specialNeed = specialNeed; }
        @Basic()
        @Column(name="\"specialNeed\"")
        private String specialNeed ;
         
        /**
         * (deprecated) (use 'priority' instead) True if this is an important customer.
         * Importance is for matters different than those in 'specialNeed' attribute.
         */
        public Boolean getVip () { return vip; }
        public void setVip ( Boolean vip ) { this.vip = vip; }
        @Basic()
        @Column(name="\"vip\"")
        private Boolean vip ;
         
        /**
         * Priority of the customer.
         */
        public Priority getPriority () { return priority; }
        public void setPriority ( Priority priority ) { this.priority = priority; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"priority\"")
        private Priority priority ;
         
        /**
         * Status of this customer.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * Assignment of a group of products and services purchased by the customer
     * through a customer agreement, used as a mechanism for customer billing
     * and payment. It contains common information from the various types of customer
     * agreements to create billings (invoices) for a customer and receive payment.
     */
    @Entity
    @Table(name="\"CustomerAccount\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CustomerAccount
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Cycle day on which the associated customer account will normally be billed,
         * used to determine when to produce the billing.
         */
        public String getBillingCycle () { return billingCycle; }
        public void setBillingCycle ( String billingCycle ) { this.billingCycle = billingCycle; }
        @Basic()
        @Column(name="\"billingCycle\"")
        private String billingCycle ;
         
        /**
         * Budget bill code.
         */
        public String getBudgetBill () { return budgetBill; }
        public void setBudgetBill ( String budgetBill ) { this.budgetBill = budgetBill; }
        @Basic()
        @Column(name="\"budgetBill\"")
        private String budgetBill ;
         
        /**
         * The last amount that will be billed to the customer prior to shut off of
         * the account.
         */
        public String getLastBillAmount () { return lastBillAmount; }
        public void setLastBillAmount ( String lastBillAmount ) { this.lastBillAmount = lastBillAmount; }
        @Basic()
        @Column(name="\"lastBillAmount\"")
        private String lastBillAmount ;
         
        /**
         */
        public AccountNotification getAccountNotification () { return accountNotification; }
        public void setAccountNotification ( AccountNotification accountNotification ) { this.accountNotification = accountNotification; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AccountNotification\"")
        private AccountNotification accountNotification ;
         
        /**
         */
        public AccountNotification getAccountNotification () { return accountNotification; }
        public void setAccountNotification ( AccountNotification accountNotification ) { this.accountNotification = accountNotification; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AccountNotification\"")
        private AccountNotification accountNotification ;
         
        /**
         * Meter read schedule that applies to the customer account
         */
        public MeterReadSchedule getMeterReadSchedule () { return meterReadSchedule; }
        public void setMeterReadSchedule ( MeterReadSchedule meterReadSchedule ) { this.meterReadSchedule = meterReadSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"MeterReadSchedule\"")
        private MeterReadSchedule meterReadSchedule ;
         
    }
    /**
     * Agreement between the customer and the service supplier to pay for service
     * at a specific service location. It records certain billing information
     * about the type of service provided at the service location and is used
     * during charge creation to determine the type of service.
     */
    @Entity
    @Table(name="\"CustomerAgreement\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CustomerAgreement
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * If true, the customer is a pre-pay customer for the specified service.
         */
        public Boolean getIsPrePay () { return isPrePay; }
        public void setIsPrePay ( Boolean isPrePay ) { this.isPrePay = isPrePay; }
        @Basic()
        @Column(name="\"isPrePay\"")
        private Boolean isPrePay ;
         
        /**
         * Load management code.
         */
        public String getLoadMgmt () { return loadMgmt; }
        public void setLoadMgmt ( String loadMgmt ) { this.loadMgmt = loadMgmt; }
        @Basic()
        @Column(name="\"loadMgmt\"")
        private String loadMgmt ;
         
        /**
         * Final date and time the service will be billed to the previous customer.
         */
        public String getShutOffDateTime () { return shutOffDateTime; }
        public void setShutOffDateTime ( String shutOffDateTime ) { this.shutOffDateTime = shutOffDateTime; }
        @Basic()
        @Column(name="\"shutOffDateTime\"")
        private String shutOffDateTime ;
         
        /**
         * Customer account owning this agreement.
         */
        public CustomerAccount getCustomerAccount () { return customerAccount; }
        public void setCustomerAccount ( CustomerAccount customerAccount ) { this.customerAccount = customerAccount; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CustomerAccount\"")
        private CustomerAccount customerAccount ;
         
        /**
         * Meter read schedule that applies to the customer agreement
         */
        public MeterReadSchedule getMeterReadSchedule () { return meterReadSchedule; }
        public void setMeterReadSchedule ( MeterReadSchedule meterReadSchedule ) { this.meterReadSchedule = meterReadSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"MeterReadSchedule\"")
        private MeterReadSchedule meterReadSchedule ;
         
    }
    /**
     * The creation of the monthly customer billing statements is the method employed
     * to notify Customers of charges, adjustments and credits applied to their
     * account for Services and Products. The actuall billing occurs through an
     * ErpInvoice. The CustomerBillingInfo includes information from the payment,
     * collection, meter reading, installed meter, service, site, customer, customer
     * account, customer agreement, services and pricing subject areas. Each component
     * price shows up as a separate line item on the ErpInvoice.
     * The Customer Billing Statement may include collection and account messages,
     * marketing/civic event messages and bill inserts.
     * One Customer Billing Statement is produced for all Agreements under a CustomerAccount
     * per billing cycle date defined in 'CustomerAccount.billingCycle'.
     * The history of CustomerBillingInfo, Invoices and Payments is to be maintained
     * in associated ActivityRecords.
     */
    @Entity
    @Table(name="\"CustomerBillingInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CustomerBillingInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Business date designated for the billing run which produced this CustomerBillingInfo.
         */
        public String getBillingDate () { return billingDate; }
        public void setBillingDate ( String billingDate ) { this.billingDate = billingDate; }
        @Basic()
        @Column(name="\"billingDate\"")
        private String billingDate ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Calculated date upon which a customer billing amount is due, used in the
         * invoicing process to determine when a Customer's Payment is delinquent.
         * It takes into consideration the regulatory criteria and the Customer's
         * requested due date. In the absence of a Customer requested due date, the
         * due date is typically calculated from the regulated number of days and
         * the 'billingDate'.
         */
        public String getDueDate () { return dueDate; }
        public void setDueDate ( String dueDate ) { this.dueDate = dueDate; }
        @Basic()
        @Column(name="\"dueDate\"")
        private String dueDate ;
         
        /**
         * Kind of bill customer receives.
         */
        public CustomerBillingKind getKind () { return kind; }
        public void setKind ( CustomerBillingKind kind ) { this.kind = kind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"kind\"")
        private CustomerBillingKind kind ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
     
    /**
     * Kind of customer.
     */
    @Entity
    @Table(name="\"CustomerKind\"")
    public static class CustomerKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Specifies the list of functions that are supported.
     */
    @Entity
    @Table(name="\"DERFunction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class DERFunction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * If set to TRUE, the connect/disconnect function is supported.
         */
        public Boolean getConnectDisconnect () { return connectDisconnect; }
        public void setConnectDisconnect ( Boolean connectDisconnect ) { this.connectDisconnect = connectDisconnect; }
        @Basic()
        @Column(name="\"connectDisconnect\"")
        private Boolean connectDisconnect ;
         
        /**
         * If set to TRUE, the maxRealPowerLimiting function is supported.
         */
        public Boolean getMaxRealPowerLimiting () { return maxRealPowerLimiting; }
        public void setMaxRealPowerLimiting ( Boolean maxRealPowerLimiting ) { this.maxRealPowerLimiting = maxRealPowerLimiting; }
        @Basic()
        @Column(name="\"maxRealPowerLimiting\"")
        private Boolean maxRealPowerLimiting ;
         
        /**
         * If set to TRUE, the realPowerDispatch function is supported.
         */
        public Boolean getRealPowerDispatch () { return realPowerDispatch; }
        public void setRealPowerDispatch ( Boolean realPowerDispatch ) { this.realPowerDispatch = realPowerDispatch; }
        @Basic()
        @Column(name="\"realPowerDispatch\"")
        private Boolean realPowerDispatch ;
         
    }
    /**
     * Primary email address.
     */
    public String getEmail1 () { return email1; }
    public void setEmail1 ( String email1 ) { this.email1 = email1; }
    @Basic()
    @Column(name="\"email1\"")
    private String email1 ;
     
    /**
     * Asset container that performs one or more end device functions. One type
     * of end device is a meter which can perform metering, load management, connect/disconnect,
     * accounting functions, etc. Some end devices, such as ones monitoring and
     * controlling air conditioners, refrigerators, pool pumps may be connected
     * to a meter. All end devices may have communication capability defined by
     * the associated communication function(s). An end device may be owned by
     * a consumer, a service provider, utility or otherwise.
     * There may be a related end device function that identifies a sensor or
     * control point within a metering application or communications systems (e.g.,
     * water, gas, electricity).
     * Some devices may use an optical port that conforms to the ANSI C12.18 standard
     * for communications.
     */
    @Entity
    @Table(name="\"EndDevice\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EndDevice
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Automated meter reading (AMR) or other communication system responsible
         * for communications to this end device.
         */
        public String getAmrSystem () { return amrSystem; }
        public void setAmrSystem ( String amrSystem ) { this.amrSystem = amrSystem; }
        @Basic()
        @Column(name="\"amrSystem\"")
        private String amrSystem ;
         
        /**
         * A code used to specify the connection category, e.g. low voltage, where
         * the meter operates.
         */
        public String getConnectionCategory () { return connectionCategory; }
        public void setConnectionCategory ( String connectionCategory ) { this.connectionCategory = connectionCategory; }
        @Basic(optional=true)
        @Column(name="\"connectionCategory\"")
        private String connectionCategory ;
         
        /**
         * Meter form designation per ANSI C12.10 or other applicable standard. An
         * alphanumeric designation denoting the circuit arrangement for which the
         * meter is applicable and its specific terminal arrangement.
         */
        public String getFormNumber () { return formNumber; }
        public void setFormNumber ( String formNumber ) { this.formNumber = formNumber; }
        @Basic(optional=true)
        @Column(name="\"formNumber\"")
        private String formNumber ;
         
        /**
         * Installation code.
         */
        public String getInstallCode () { return installCode; }
        public void setInstallCode ( String installCode ) { this.installCode = installCode; }
        @Basic()
        @Column(name="\"installCode\"")
        private String installCode ;
         
        /**
         * Usage point to which this end device belongs.
         */
        public UsagePoint getUsagePoint () { return usagePoint; }
        public void setUsagePoint ( UsagePoint usagePoint ) { this.usagePoint = usagePoint; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"UsagePoint\"")
        private UsagePoint usagePoint ;
         
    }
    /**
     * Abstraction for management of group communications within a two-way AMR
     * system or the data for a group of related end devices. Commands can be
     * issued to all of the end devices that belong to the group using a defined
     * group address and the underlying AMR communication infrastructure. A DERGroup
     * and a PANDeviceGroup is an EndDeviceGroup.
     */
    @Entity
    @Table(name="\"EndDeviceGroup\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EndDeviceGroup
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Type of this group.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * A roll up of invoice line items. The whole invoice has a due date and amount
     * to be paid, with information such as customer, banks etc. being obtained
     * through associations. The invoice roll up is based on individual line items
     * that each contain amounts and descriptions for specific services or products.
     */
    @Entity
    @Table(name="\"ErpInvoice\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ErpInvoice
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Total amount due on this invoice based on line items and applicable adjustments.
         */
        public String getAmount () { return amount; }
        public void setAmount ( String amount ) { this.amount = amount; }
        @Basic()
        @Column(name="\"amount\"")
        private String amount ;
         
        /**
         * Kind of media by which the CustomerBillingInfo was delivered.
         */
        public String getBillMediaKind () { return billMediaKind; }
        public void setBillMediaKind ( String billMediaKind ) { this.billMediaKind = billMediaKind; }
        @Basic()
        @Column(name="\"billMediaKind\"")
        private String billMediaKind ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Calculated date upon which the Invoice amount is due.
         */
        public String getDueDate () { return dueDate; }
        public void setDueDate ( String dueDate ) { this.dueDate = dueDate; }
        @Basic()
        @Column(name="\"dueDate\"")
        private String dueDate ;
         
        /**
         * Kind of invoice (default is 'sales').
         */
        public ErpInvoiceKind getKind () { return kind; }
        public void setKind ( ErpInvoiceKind kind ) { this.kind = kind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"kind\"")
        private ErpInvoiceKind kind ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
    }
    /**
     * Description of a problem in the field that may be reported in a trouble
     * ticket or come from another source. It may have to do with an outage.
     */
    @Entity
    @Table(name="\"Incident\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Incident
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * Cause of this incident.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic()
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * Hazardous situation associated with an incident. Examples are line down,
     * gas leak, fire, etc.
     */
    @Entity
    @Table(name="\"IncidentHazard\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class IncidentHazard
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Type of this hazard.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     */
    @Entity
    @Table(name="\"MeterReadSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MeterReadSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
    }
    /**
     * Grouping of pricing components and prices used in the creation of customer
     * charges and the eligibility criteria under which these terms may be offered
     * to a customer. The reasons for grouping include state, customer classification,
     * site characteristics, classification (i.e. fee price structure, deposit
     * price structure, electric service price structure, etc.) and accounting
     * requirements.
     */
    @Entity
    @Table(name="\"PricingStructure\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PricingStructure
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
    }
    /**
     * Description of anything that changes through time. Time schedule is used
     * to perform a single-valued function of time. Use inherited 'type' attribute
     * to give additional information on this schedule, such as: periodic (hourly,
     * daily, weekly, monthly, etc.), day of the month, by date, calendar (specific
     * times and dates).
     */
    @Entity
    @Table(name="\"TimeSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TimeSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
    }
    /**
     * Trouble order sends an incident to a crew to initiate a response to an
     * unplanned outage.
     */
    @Entity
    @Table(name="\"TroubleOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Free-form comment associated with the trouble order.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Electronic address.
         */
        public ElectronicAddress getElectronicAddress () { return electronicAddress; }
        public void setElectronicAddress ( ElectronicAddress electronicAddress ) { this.electronicAddress = electronicAddress; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"electronicAddress\"")
        private ElectronicAddress electronicAddress ;
         
        /**
         * The incident that may be associated with the trouble order.
         */
        public Incident getIncident () { return incident; }
        public void setIncident ( Incident incident ) { this.incident = incident; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Incident\"")
        private Incident incident ;
         
        /**
         * Issuer of this document.
         */
        public Issuer getIssuer () { return issuer; }
        public void setIssuer ( Issuer issuer ) { this.issuer = issuer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Issuer\"")
        private Issuer issuer ;
         
        /**
         * The location of this trouble order
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
        /**
         * The planned start and end time for the trouble order.
         */
        public DateTimeInterval getPlannedExecutionInterval () { return plannedExecutionInterval; }
        public void setPlannedExecutionInterval ( DateTimeInterval plannedExecutionInterval ) { this.plannedExecutionInterval = plannedExecutionInterval; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"plannedExecutionInterval\"")
        private DateTimeInterval plannedExecutionInterval ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
        /**
         * The unplanned outage that is associated to the Trouble Order.
         */
        public UnplannedOutage getUnplannedOutage () { return unplannedOutage; }
        public void setUnplannedOutage ( UnplannedOutage unplannedOutage ) { this.unplannedOutage = unplannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"UnplannedOutage\"")
        private UnplannedOutage unplannedOutage ;
         
    }
    /**
     */
    @Entity
    @Table(name="\"TroubleTicket\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleTicket
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free-form comment associated with the trouble call for example, "customer
         * reported a large flash", etc.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time the trouble has been reported.
         */
        public String getDateTimeOfReport () { return dateTimeOfReport; }
        public void setDateTimeOfReport ( String dateTimeOfReport ) { this.dateTimeOfReport = dateTimeOfReport; }
        @Basic()
        @Column(name="\"dateTimeOfReport\"")
        private String dateTimeOfReport ;
         
        /**
         * Indicates whether the first responder such as police, fire department etc.has
         * been notified and whether they are on site or en route.
         */
        public String getFirstResponderStatus () { return firstResponderStatus; }
        public void setFirstResponderStatus ( String firstResponderStatus ) { this.firstResponderStatus = firstResponderStatus; }
        @Basic()
        @Column(name="\"firstResponderStatus\"")
        private String firstResponderStatus ;
         
        /**
         * Set to true if the outage report indicated that other neighbors are also
         * out of power.
         */
        public Boolean getMultiplePremises () { return multiplePremises; }
        public void setMultiplePremises ( Boolean multiplePremises ) { this.multiplePremises = multiplePremises; }
        @Basic()
        @Column(name="\"multiplePremises\"")
        private Boolean multiplePremises ;
         
        /**
         * Indicates how the customer reported trouble.
         */
        public TroubleReportingKind getReportingKind () { return reportingKind; }
        public void setReportingKind ( TroubleReportingKind reportingKind ) { this.reportingKind = reportingKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"reportingKind\"")
        private TroubleReportingKind reportingKind ;
         
        /**
         * Date and time this trouble ticket has been resolved.
         */
        public String getResolvedDateTime () { return resolvedDateTime; }
        public void setResolvedDateTime ( String resolvedDateTime ) { this.resolvedDateTime = resolvedDateTime; }
        @Basic()
        @Column(name="\"resolvedDateTime\"")
        private String resolvedDateTime ;
         
        /**
         * Trouble code (e.g., power down, flickering lights, partial power, etc).
         */
        public String getTroubleCode () { return troubleCode; }
        public void setTroubleCode ( String troubleCode ) { this.troubleCode = troubleCode; }
        @Basic()
        @Column(name="\"troubleCode\"")
        private String troubleCode ;
         
        /**
         * Incident reported in this trouble ticket
         */
        public Incident getIncident () { return incident; }
        public void setIncident ( Incident incident ) { this.incident = incident; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Incident\"")
        private Incident incident ;
         
        /**
         * The order to which one or more trouble tickets are associated.
         */
        public TroubleOrder getTroubleOrder () { return troubleOrder; }
        public void setTroubleOrder ( TroubleOrder troubleOrder ) { this.troubleOrder = troubleOrder; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TroubleOrder\"")
        private TroubleOrder troubleOrder ;
         
        /**
         * The unplanned outage to which one or more trouble tickets are associated.
         */
        public UnplannedOutage getUnplannedOutage () { return unplannedOutage; }
        public void setUnplannedOutage ( UnplannedOutage unplannedOutage ) { this.unplannedOutage = unplannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"UnplannedOutage\"")
        private UnplannedOutage unplannedOutage ;
         
    }
    /**
     * Document describing the consequence of an unplanned outage in a part of
     * the electrical network. For the purposes of this model, an unplanned outage
     * refers to a state where energy is not delivered; such as, customers out
     * of service, a street light is not served, etc.
     * A unplanned outage may be created upon:
     * - impacts the SAIDI calculation
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     */
    @Entity
    @Table(name="\"UnplannedOutage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class UnplannedOutage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The cause of this outage. This is the cause that is used to present to
         * external entities. That is, the cause is weather, equipment failure, etc.
         * Note: At present, this is a free string text; it could be replaced with
         * an enumeration in the future.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic()
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * The possible cause that could be associated with this unplanned outage.
         */
        public OutageCauseKind getCauseKind () { return causeKind; }
        public void setCauseKind ( OutageCauseKind causeKind ) { this.causeKind = causeKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"causeKind\"")
        private OutageCauseKind causeKind ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * a name to denote the community - this could be a name or a code of some
         * kind.
         */
        public String getCommunityDescriptor () { return communityDescriptor; }
        public void setCommunityDescriptor ( String communityDescriptor ) { this.communityDescriptor = communityDescriptor; }
        @Basic()
        @Column(name="\"communityDescriptor\"")
        private String communityDescriptor ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public OutageStatusKind getOutageKind () { return outageKind; }
        public void setOutageKind ( OutageStatusKind outageKind ) { this.outageKind = outageKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"outageKind\"")
        private OutageStatusKind outageKind ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public CrewStatusKind getStatusKind () { return statusKind; }
        public void setStatusKind ( CrewStatusKind statusKind ) { this.statusKind = statusKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"statusKind\"")
        private CrewStatusKind statusKind ;
         
        /**
         * This contains an disclaimers the utility would like to place on the data
         * provided to any stakeholder. This may be different for different stakeholders.
         * This should possibly be an attribute under the Organization class but it
         * is placed here for now.
         */
        public String getUtilityDisclaimer () { return utilityDisclaimer; }
        public void setUtilityDisclaimer ( String utilityDisclaimer ) { this.utilityDisclaimer = utilityDisclaimer; }
        @Basic()
        @Column(name="\"utilityDisclaimer\"")
        private String utilityDisclaimer ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * Logical or physical point in the network to which readings or events may
     * be attributed. Used at the place where a physical or virtual meter may
     * be located; however, it is not required that a meter be present.
     */
    @Entity
    @Table(name="\"UsagePoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class UsagePoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        AccountNotification.class,
        BillMediaKind.class,
        Customer.class,
        CustomerAccount.class,
        CustomerAgreement.class,
        CustomerBillingInfo.class,
        CustomerKind.class,
        DERFunction.class,
        EndDevice.class,
        EndDeviceGroup.class,
        ErpInvoice.class,
        Incident.class,
        IncidentHazard.class,
        MeterReadSchedule.class,
        PricingStructure.class,
        TimeSchedule.class,
        TroubleOrder.class,
        TroubleTicket.class,
        UnplannedOutage.class,
        UsagePoint.class
    };
}
