package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for EAM_OMS_Profile
 * Generated by CIMTool http://cimtool.org
 */
public class EAM_OMS_Profile
{
    /**
     * Date and time the asset was last tested using the 'type' of test and yielding
     * the current status in 'success' attribute.
     */
    public String getDateTime () { return dateTime; }
    public void setDateTime ( String dateTime ) { this.dateTime = dateTime; }
    @Basic()
    @Column(name="\"dateTime\"")
    private String dateTime ;
     
    /**
     * True if asset has passed acceptance test and may be placed in or is in
     * service. It is set to false if asset is removed from service and is required
     * to be tested again before being placed back in service, possibly in a new
     * location. Since asset may go through multiple tests during its lifecycle,
     * the date of each acceptance test may be recorded in 'Asset.ActivityRecord.status.dateTime'.
     */
    public Boolean getSuccess () { return success; }
    public void setSuccess ( Boolean success ) { this.success = success; }
    @Basic()
    @Column(name="\"success\"")
    private Boolean success ;
     
    /**
     * Type of test or group of tests that was conducted on 'dateTime'.
     */
    public String getType () { return type; }
    public void setType ( String type ) { this.type = type; }
    @Basic()
    @Column(name="\"type\"")
    private String type ;
     
    /**
     * Records activity for an entity at a point in time; activity may be for
     * an event that has already occurred or for a planned activity.
     */
    @Entity
    @Table(name="\"ActivityRecord\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ActivityRecord
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time this activity record has been created (different from the
         * 'status.dateTime', which is the time of a status change of the associated
         * object, if applicable).
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Reason for event resulting in this activity record, typically supplied
         * when user initiated.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Severity level of event resulting in this activity record.
         */
        public String getSeverity () { return severity; }
        public void setSeverity ( String severity ) { this.severity = severity; }
        @Basic()
        @Column(name="\"severity\"")
        private String severity ;
         
        /**
         * Type of event resulting in this activity record.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Information on consequence of event resulting in this activity record.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * An algorithm or calculation for making an assessment about an asset or
     * asset grouping for lifecycle decision making.
     */
    @Entity
    @Table(name="\"Analytic\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Analytic
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Value that indicates best possible numeric value.
         */
        public Double getBestValue () { return bestValue; }
        public void setBestValue ( Double bestValue ) { this.bestValue = bestValue; }
        @Basic()
        @Column(name="\"bestValue\"")
        private Double bestValue ;
         
        /**
         * Kind of analytic this analytic is.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * The scoring scale kind.
         */
        public String getScaleKind () { return scaleKind; }
        public void setScaleKind ( String scaleKind ) { this.scaleKind = scaleKind; }
        @Basic()
        @Column(name="\"scaleKind\"")
        private String scaleKind ;
         
        /**
         * Value that indicates worst possible numeric value.
         */
        public Double getWorstValue () { return worstValue; }
        public void setWorstValue ( Double worstValue ) { this.worstValue = worstValue; }
        @Basic()
        @Column(name="\"worstValue\"")
        private Double worstValue ;
         
    }
     
    /**
     * Possible kinds of analytics.
     */
    @Entity
    @Table(name="\"AnalyticKind\"")
    public static class AnalyticKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * An indicative scoring by an analytic that can be used to characterize the
     * health of or the risk associated with one or more assets. The analytic
     * score reflects the results of an execution of an analytic against an asset
     * or group of assets.
     */
    @Entity
    @Table(name="\"AnalyticScore\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AnalyticScore
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Timestamp of when the score was calculated.
         */
        public String getCalculationDateTime () { return calculationDateTime; }
        public void setCalculationDateTime ( String calculationDateTime ) { this.calculationDateTime = calculationDateTime; }
        @Basic()
        @Column(name="\"calculationDateTime\"")
        private String calculationDateTime ;
         
        /**
         * Date-time for when the score applies.
         */
        public String getEffectiveDateTime () { return effectiveDateTime; }
        public void setEffectiveDateTime ( String effectiveDateTime ) { this.effectiveDateTime = effectiveDateTime; }
        @Basic()
        @Column(name="\"effectiveDateTime\"")
        private String effectiveDateTime ;
         
        /**
         * Asset health score value.
         */
        public Double getValue () { return value; }
        public void setValue ( Double value ) { this.value = value; }
        @Basic()
        @Column(name="\"value\"")
        private Double value ;
         
    }
    /**
     * Tangible resource of the utility, including power system equipment, various
     * end devices, cabinets, buildings, etc. For electrical network equipment,
     * the role of the asset is defined through PowerSystemResource and its subclasses,
     * defined mainly in the Wires model (refer to IEC61970-301 and model package
     * IEC61970::Wires). Asset description places emphasis on the physical characteristics
     * of the equipment fulfilling that role.
     */
    @Entity
    @Table(name="\"Asset\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Asset
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic(optional=true)
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic(optional=true)
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Condition of asset at last baseline. Examples include new, rebuilt, overhaul
         * required, other. Refer to inspection data for information on the most current
         * condition of the asset.
         */
        public String getInitialCondition () { return initialCondition; }
        public void setInitialCondition ( String initialCondition ) { this.initialCondition = initialCondition; }
        @Basic(optional=true)
        @Column(name="\"initialCondition\"")
        private String initialCondition ;
         
        /**
         * Percentage of initial life expectancy that has been lost as of the last
         * life expectancy baseline. Represents
         * (initial life expectancy - current life expectancy) / initial life expectancy.
         */
        public Double getInitialLossOfLife () { return initialLossOfLife; }
        public void setInitialLossOfLife ( Double initialLossOfLife ) { this.initialLossOfLife = initialLossOfLife; }
        @Basic(optional=true)
        @Column(name="\"initialLossOfLife\"")
        private Double initialLossOfLife ;
         
        /**
         * Indication of whether asset is currently deployed (in use), ready to be
         * put into use or not available for use.
         */
        public String getInUseState () { return inUseState; }
        public void setInUseState ( String inUseState ) { this.inUseState = inUseState; }
        @Basic(optional=true)
        @Column(name="\"inUseState\"")
        private String inUseState ;
         
        /**
         * Kind of asset. Used in description of asset components in asset instance
         * templates.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic(optional=true)
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Current lifecycle state of asset.
         */
        public String getLifecycleState () { return lifecycleState; }
        public void setLifecycleState ( String lifecycleState ) { this.lifecycleState = lifecycleState; }
        @Basic(optional=true)
        @Column(name="\"lifecycleState\"")
        private String lifecycleState ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic(optional=true)
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Serial number of this asset.
         */
        public String getSerialNumber () { return serialNumber; }
        public void setSerialNumber ( String serialNumber ) { this.serialNumber = serialNumber; }
        @Basic(optional=true)
        @Column(name="\"serialNumber\"")
        private String serialNumber ;
         
        /**
         * Utility-specific classification of Asset and its subtypes, according to
         * their corporate standards, practices, and existing IT systems (e.g., for
         * management of assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic(optional=true)
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * This asset's deployment.
         */
        public AssetDeployment getAssetDeployment () { return assetDeployment; }
        public void setAssetDeployment ( AssetDeployment assetDeployment ) { this.assetDeployment = assetDeployment; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"AssetDeployment\"")
        private AssetDeployment assetDeployment ;
         
        /**
         * In use dates for this asset.
         */
        public InUseDate getInUseDate () { return inUseDate; }
        public void setInUseDate ( InUseDate inUseDate ) { this.inUseDate = inUseDate; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"inUseDate\"")
        private InUseDate inUseDate ;
         
        /**
         * Location of this asset.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
        /**
         * Status of this asset.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * Asset that is aggregation of other assets such as conductors, transformers,
     * switchgear, land, fences, buildings, equipment, vehicles, etc.
     */
    @Entity
    @Table(name="\"AssetContainer\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class AssetContainer extends Asset
    {
    }
    /**
     * Deployment of asset deployment in a power system resource role.
     */
    @Entity
    @Table(name="\"AssetDeployment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AssetDeployment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Current deployment state of asset.
         */
        public DeploymentStateKind getDeploymentState () { return deploymentState; }
        public void setDeploymentState ( DeploymentStateKind deploymentState ) { this.deploymentState = deploymentState; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"deploymentState\"")
        private DeploymentStateKind deploymentState ;
         
        /**
         * Kind of facility (like substation or pole or building or plant or service
         * center) at which asset deployed.
         */
        public FacilityKind getFacilityKind () { return facilityKind; }
        public void setFacilityKind ( FacilityKind facilityKind ) { this.facilityKind = facilityKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"facilityKind\"")
        private FacilityKind facilityKind ;
         
        /**
         * Likelihood of asset failure on a scale of 1(low) to 100 (high).
         */
        public Integer getLikelihoodOfFailure () { return likelihoodOfFailure; }
        public void setLikelihoodOfFailure ( Integer likelihoodOfFailure ) { this.likelihoodOfFailure = likelihoodOfFailure; }
        @Basic()
        @Column(name="\"likelihoodOfFailure\"")
        private Integer likelihoodOfFailure ;
         
        /**
         * Type of network role transformer is playing in this deployment (applies
         * to transformer assets only).
         */
        public TransformerApplicationKind getTransformerApplication () { return transformerApplication; }
        public void setTransformerApplication ( TransformerApplicationKind transformerApplication ) { this.transformerApplication = transformerApplication; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"transformerApplication\"")
        private TransformerApplicationKind transformerApplication ;
         
    }
    /**
     * An asset health-related event that is created by an analytic. The event
     * is a record of a change in asset health.
     */
    @Entity
    @Table(name="\"AssetHealthEvent\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class AssetHealthEvent extends ActivityRecord
    {
        /**
         * Recommendation for action.
         */
        public String getActionRecommendation () { return actionRecommendation; }
        public void setActionRecommendation ( String actionRecommendation ) { this.actionRecommendation = actionRecommendation; }
        @Basic()
        @Column(name="\"actionRecommendation\"")
        private String actionRecommendation ;
         
        /**
         * Time horizon for action.
         */
        public String getActionTimeline () { return actionTimeline; }
        public void setActionTimeline ( String actionTimeline ) { this.actionTimeline = actionTimeline; }
        @Basic()
        @Column(name="\"actionTimeline\"")
        private String actionTimeline ;
         
        /**
         * Date and time this activity record has been created (different from the
         * 'status.dateTime', which is the time of a status change of the associated
         * object, if applicable).
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The date and time when the event is effective.
         */
        public String getEffectiveDateTime () { return effectiveDateTime; }
        public void setEffectiveDateTime ( String effectiveDateTime ) { this.effectiveDateTime = effectiveDateTime; }
        @Basic()
        @Column(name="\"effectiveDateTime\"")
        private String effectiveDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Reason for event resulting in this activity record, typically supplied
         * when user initiated.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Severity level of event resulting in this activity record.
         */
        public String getSeverity () { return severity; }
        public void setSeverity ( String severity ) { this.severity = severity; }
        @Basic()
        @Column(name="\"severity\"")
        private String severity ;
         
        /**
         * Type of event resulting in this activity record.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
     
    /**
     * Kinds of assets or asset components.
     */
    @Entity
    @Table(name="\"AssetKind\"")
    public static class AssetKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Lifecycle states an asset can be in.
     * While the possible lifecycle states are standardized, the allowed transitions
     * are not - they are intended to be defined by the business process requirements
     * of local implementations.
     */
    @Entity
    @Table(name="\"AssetLifecycleStateKind\"")
    public static class AssetLifecycleStateKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Group of people with specific skills, tools, and vehicles.
     */
    @Entity
    @Table(name="\"Crew\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Crew
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Type of this crew.
         */
        public CrewType getCrewType () { return crewType; }
        public void setCrewType ( CrewType crewType ) { this.crewType = crewType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CrewType\"")
        private CrewType crewType ;
         
    }
    /**
     * Member of a crew.
     */
    @Entity
    @Table(name="\"CrewMember\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CrewMember
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
    /**
     * Custom description of the type of crew. This may be used to determine the
     * type of work the crew can be assigned to. Examples include repair, tree
     * trimming, switching, etc.
     */
    @Entity
    @Table(name="\"CrewType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CrewType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * The parts of a power system that are physical devices, electronic or mechanical.
     */
    @Entity
    @Table(name="\"Equipment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Equipment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Abnormal condition causing current flow through conducting equipment, such
     * as caused by equipment failure or short circuits from objects not typically
     * modelled (for example, a tree falling on a line).
     */
    @Entity
    @Table(name="\"Fault\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Fault
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Equipment carrying this fault.
         */
        public Equipment getFaultyEquipment () { return faultyEquipment; }
        public void setFaultyEquipment ( Equipment faultyEquipment ) { this.faultyEquipment = faultyEquipment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FaultyEquipment\"")
        private Equipment faultyEquipment ;
         
    }
     
    /**
     * Possible 'in use' states that an asset can be in.
     */
    @Entity
    @Table(name="\"InUseStateKind\"")
    public static class InUseStateKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A Measurement represents any measured, calculated or non-measured non-calculated
     * quantity. Any piece of equipment may contain Measurements, e.g. a substation
     * may have temperature measurements and door open indications, a transformer
     * may have oil temperature and tank pressure measurements, a bay may contain
     * a number of power flow measurements and a Breaker may contain a switch
     * status measurement.
     * The PSR - Measurement association is intended to capture this use of Measurement
     * and is included in the naming hierarchy based on EquipmentContainer. The
     * naming hierarchy typically has Measurements as leaves, e.g. Substation-VoltageLevel-Bay-Switch-Measurement.
     * Some Measurements represent quantities related to a particular sensor location
     * in the network, e.g. a voltage transformer (VT) or potential transformer
     * (PT) at a busbar or a current transformer (CT) at the bar between a breaker
     * and an isolator. The sensing position is not captured in the PSR - Measurement
     * association. Instead it is captured by the Measurement - Terminal association
     * that is used to define the sensing location in the network topology. The
     * location is defined by the connection of the Terminal to ConductingEquipment.
     * If both a Terminal and PSR are associated, and the PSR is of type ConductingEquipment,
     * the associated Terminal should belong to that ConductingEquipment instance.
     * When the sensor location is needed both Measurement-PSR and Measurement-Terminal
     * are used. The Measurement-Terminal association is never used alone.
     */
    @Entity
    @Table(name="\"Measurement\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Measurement
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Specifies the type of measurement. For example, this specifies if the measurement
         * represents an indoor temperature, outdoor temperature, bus voltage, line
         * flow, etc.
         * When the measurementType is set to "Specialization", the type of Measurement
         * is defined in more detail by the specialized class which inherits from
         * Measurement.
         */
        public String getMeasurementType () { return measurementType; }
        public void setMeasurementType ( String measurementType ) { this.measurementType = measurementType; }
        @Basic()
        @Column(name="\"measurementType\"")
        private String measurementType ;
         
        /**
         * Indicates to which phases the measurement applies and avoids the need to
         * use 'measurementType' to also encode phase information (which would explode
         * the types). The phase information in Measurement, along with 'measurementType'
         * and 'phases' uniquely defines a Measurement for a device, based on normal
         * network phase. Their meaning will not change when the computed energizing
         * phasing is changed due to jumpers or other reasons.
         * If the attribute is missing three phases (ABC) shall be assumed.
         */
        public PhaseCode getPhases () { return phases; }
        public void setPhases ( PhaseCode phases ) { this.phases = phases; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phases\"")
        private PhaseCode phases ;
         
        /**
         * The unit multiplier of the measured quantity.
         */
        public UnitMultiplier getUnitMultiplier () { return unitMultiplier; }
        public void setUnitMultiplier ( UnitMultiplier unitMultiplier ) { this.unitMultiplier = unitMultiplier; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"unitMultiplier\"")
        private UnitMultiplier unitMultiplier ;
         
        /**
         * The unit of measure of the measured quantity.
         */
        public UnitSymbol getUnitSymbol () { return unitSymbol; }
        public void setUnitSymbol ( UnitSymbol unitSymbol ) { this.unitSymbol = unitSymbol; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"unitSymbol\"")
        private UnitSymbol unitSymbol ;
         
    }
    /**
     * The current state for a measurement. A state value is an instance of a
     * measurement from a specific source. Measurements can be associated with
     * many state values, each representing a different source for the measurement.
     */
    @Entity
    @Table(name="\"MeasurementValue\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MeasurementValue
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The limit, expressed as a percentage of the sensor maximum, that errors
         * will not exceed when the sensor is used under reference conditions.
         */
        public Double getSensorAccuracy () { return sensorAccuracy; }
        public void setSensorAccuracy ( Double sensorAccuracy ) { this.sensorAccuracy = sensorAccuracy; }
        @Basic()
        @Column(name="\"sensorAccuracy\"")
        private Double sensorAccuracy ;
         
        /**
         * The time when the value was last updated.
         */
        public String getTimeStamp () { return timeStamp; }
        public void setTimeStamp ( String timeStamp ) { this.timeStamp = timeStamp; }
        @Basic()
        @Column(name="\"timeStamp\"")
        private String timeStamp ;
         
        /**
         * The value to supervise.
         */
        public Double getValue () { return value; }
        public void setValue ( Double value ) { this.value = value; }
        @Basic(optional=true)
        @Column(name="\"value\"")
        private Double value ;
         
        /**
         * The value to supervise. The value is positive.
         */
        public Integer getValue () { return value; }
        public void setValue ( Integer value ) { this.value = value; }
        @Basic(optional=true)
        @Column(name="\"value\"")
        private Integer value ;
         
    }
    /**
     * Measurement quality flags. Bits 0-10 are defined for substation automation
     * in IEC 61850-7-3. Bits 11-15 are reserved for future expansion by that
     * document. Bits 16-31 are reserved for EMS applications.
     */
    @Entity
    @Table(name="\"MeasurementValueQuality\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MeasurementValueQuality
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * The Name class provides the means to define any number of human readable
     * names for an object. A name is <b>not</b> to be used for defining inter-object
     * relationships. For inter-object relationships instead use the object identification
     * 'mRID'.
     */
    @Entity
    @Table(name="\"Name\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Name
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Any free text that name the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Identified object that this name designates.
         */
        public IdentifiedObject getIdentifiedObject () { return identifiedObject; }
        public void setIdentifiedObject ( IdentifiedObject identifiedObject ) { this.identifiedObject = identifiedObject; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"IdentifiedObject\"")
        private IdentifiedObject identifiedObject ;
         
        /**
         * Type of this name.
         */
        public NameType getNameType () { return nameType; }
        public void setNameType ( NameType nameType ) { this.nameType = nameType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"NameType\"")
        private NameType nameType ;
         
    }
    /**
     * Type of name. Possible values for attribute 'name' are implementation dependent
     * but standard profiles may specify types. An enterprise may have multiple
     * IT systems each having its own local name for the same object, e.g. a planning
     * system may have different names from an EMS. An object may also have different
     * names within the same IT system, e.g. localName as defined in CIM version
     * 14. The definition from CIM14 is:
     * The localName is a human readable name of the object. It is a free text
     * name local to a node in a naming hierarchy similar to a file directory
     * structure. A power system related naming hierarchy may be: Substation,
     * VoltageLevel, Equipment etc. Children of the same parent in such a hierarchy
     * have names that typically are unique among them.
     */
    @Entity
    @Table(name="\"NameType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class NameType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Description of the name type.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Name of the name type.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * Document describing details of an active or planned outage in a part of
     * the electrical network.
     * A non-planned outage may be created upon:
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     * A planned outage may be created upon:
     * - a request for service, maintenance or construction work in the field,
     * or
     * - an operator-defined outage for what-if/contingency network analysis.
     */
    @Entity
    @Table(name="\"Outage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Outage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * a name to denote the community - this could be a name or a code of some
         * kind.
         */
        public String getCommunityDescriptor () { return communityDescriptor; }
        public void setCommunityDescriptor ( String communityDescriptor ) { this.communityDescriptor = communityDescriptor; }
        @Basic()
        @Column(name="\"communityDescriptor\"")
        private String communityDescriptor ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * the total number of customers that are served in the area (both outaged
         * and not outaged).
         */
        public Integer getOriginalCustomersServed () { return originalCustomersServed; }
        public void setOriginalCustomersServed ( Integer originalCustomersServed ) { this.originalCustomersServed = originalCustomersServed; }
        @Basic()
        @Column(name="\"originalCustomersServed\"")
        private Integer originalCustomersServed ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public OutageStatusKind getOutageKind () { return outageKind; }
        public void setOutageKind ( OutageStatusKind outageKind ) { this.outageKind = outageKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"outageKind\"")
        private OutageStatusKind outageKind ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public CrewStatusKind getStatusKind () { return statusKind; }
        public void setStatusKind ( CrewStatusKind statusKind ) { this.statusKind = statusKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"statusKind\"")
        private CrewStatusKind statusKind ;
         
        /**
         * This contains an disclaimers the utility would like to place on the data
         * provided to any stakeholder. This may be different for different stakeholders.
         * This should possibly be an attribute under the Organization class but it
         * is placed here for now.
         */
        public String getUtilityDisclaimer () { return utilityDisclaimer; }
        public void setUtilityDisclaimer ( String utilityDisclaimer ) { this.utilityDisclaimer = utilityDisclaimer; }
        @Basic()
        @Column(name="\"utilityDisclaimer\"")
        private String utilityDisclaimer ;
         
    }
    /**
     * General purpose information for name and other information to contact people.
     */
    @Entity
    @Table(name="\"Person\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Person
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Middle name(s) or initial(s).
         */
        public String getMName () { return mName; }
        public void setMName ( String mName ) { this.mName = mName; }
        @Basic()
        @Column(name="\"mName\"")
        private String mName ;
         
    }
     
    /**
     * An unordered enumeration of phase identifiers. Allows designation of phases
     * for both transmission and distribution equipment, circuits and loads. The
     * enumeration, by itself, does not describe how the phases are connected
     * together or connected to ground. Ground is not explicitly denoted as a
     * phase.
     * Residential and small commercial loads are often served from single-phase,
     * or split-phase, secondary circuits. For the example of s12N, phases 1 and
     * 2 refer to hot wires that are 180 degrees out of phase, while N refers
     * to the neutral wire. Through single-phase transformer connections, these
     * secondary circuits may be served from one or two of the primary phases
     * A, B, and C. For three-phase loads, use the A, B, C phase codes instead
     * of s12N.
     * The integer values are from IEC 61968-9 to support revenue metering applications.
     */
    @Entity
    @Table(name="\"PhaseCode\"")
    public static class PhaseCode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A data set recorded each time a procedure is executed. Observed results
     * are captured in associated measurement values and/or values for properties
     * relevant to the type of procedure performed.
     */
    @Entity
    @Table(name="\"ProcedureDataSet\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ProcedureDataSet
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time procedure was completed.
         */
        public String getCompletedDateTime () { return completedDateTime; }
        public void setCompletedDateTime ( String completedDateTime ) { this.completedDateTime = completedDateTime; }
        @Basic()
        @Column(name="\"completedDateTime\"")
        private String completedDateTime ;
         
        /**
         * Condition of asset just following maintenance procedure.
         */
        public String getConditionAfter () { return conditionAfter; }
        public void setConditionAfter ( String conditionAfter ) { this.conditionAfter = conditionAfter; }
        @Basic(optional=true)
        @Column(name="\"conditionAfter\"")
        private String conditionAfter ;
         
        /**
         * Description of the condition of the asset just prior to maintenance being
         * performed.
         */
        public String getConditionBefore () { return conditionBefore; }
        public void setConditionBefore ( String conditionBefore ) { this.conditionBefore = conditionBefore; }
        @Basic(optional=true)
        @Column(name="\"conditionBefore\"")
        private String conditionBefore ;
         
        /**
         * Effect of problem.
         */
        public String getEffect () { return effect; }
        public void setEffect ( String effect ) { this.effect = effect; }
        @Basic(optional=true)
        @Column(name="\"effect\"")
        private String effect ;
         
        /**
         * Failuer mode, for example: Failure to Insulate; Failure to conduct; Failure
         * to contain oil; Failure to provide ground plane; Other.
         */
        public String getFailureMode () { return failureMode; }
        public void setFailureMode ( String failureMode ) { this.failureMode = failureMode; }
        @Basic(optional=true)
        @Column(name="\"failureMode\"")
        private String failureMode ;
         
        /**
         * Cause of problem determined during diagnosis.
         */
        public String getFinalCause () { return finalCause; }
        public void setFinalCause ( String finalCause ) { this.finalCause = finalCause; }
        @Basic(optional=true)
        @Column(name="\"finalCause\"")
        private String finalCause ;
         
        /**
         * Code for diagnosed probem type.
         */
        public String getFinalCode () { return finalCode; }
        public void setFinalCode ( String finalCode ) { this.finalCode = finalCode; }
        @Basic(optional=true)
        @Column(name="\"finalCode\"")
        private String finalCode ;
         
        /**
         * Origin of problem determined during diagnosis.
         */
        public String getFinalOrigin () { return finalOrigin; }
        public void setFinalOrigin ( String finalOrigin ) { this.finalOrigin = finalOrigin; }
        @Basic(optional=true)
        @Column(name="\"finalOrigin\"")
        private String finalOrigin ;
         
        /**
         * Remarks pertaining to findings during problem diagnosis.
         */
        public String getFinalRemark () { return finalRemark; }
        public void setFinalRemark ( String finalRemark ) { this.finalRemark = finalRemark; }
        @Basic(optional=true)
        @Column(name="\"finalRemark\"")
        private String finalRemark ;
         
        /**
         * Code for the type of maintenance performed.
         */
        public String getMaintCode () { return maintCode; }
        public void setMaintCode ( String maintCode ) { this.maintCode = maintCode; }
        @Basic(optional=true)
        @Column(name="\"maintCode\"")
        private String maintCode ;
         
        /**
         * Phase(s) diagnosed.
         */
        public String getPhaseCode () { return phaseCode; }
        public void setPhaseCode ( String phaseCode ) { this.phaseCode = phaseCode; }
        @Basic(optional=true)
        @Column(name="\"phaseCode\"")
        private String phaseCode ;
         
        /**
         * Root cause of problem determined during diagnosis.
         */
        public String getRootCause () { return rootCause; }
        public void setRootCause ( String rootCause ) { this.rootCause = rootCause; }
        @Basic(optional=true)
        @Column(name="\"rootCause\"")
        private String rootCause ;
         
        /**
         * Procedure capturing this data set.
         */
        public Procedure getProcedure () { return procedure; }
        public void setProcedure ( Procedure procedure ) { this.procedure = procedure; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Procedure\"")
        private Procedure procedure ;
         
    }
     
    /**
     * Reason asset retired.
     */
    @Entity
    @Table(name="\"RetiredReasonKind\"")
    public static class RetiredReasonKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Kinds of scaling.
     */
    @Entity
    @Table(name="\"ScaleKind\"")
    public static class ScaleKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Date and time for which status 'value' applies.
     */
    public String getDateTime () { return dateTime; }
    public void setDateTime ( String dateTime ) { this.dateTime = dateTime; }
    @Basic()
    @Column(name="\"dateTime\"")
    private String dateTime ;
     
    /**
     * Reason code or explanation for why an object went to the current status
     * 'value'.
     */
    public String getReason () { return reason; }
    public void setReason ( String reason ) { this.reason = reason; }
    @Basic()
    @Column(name="\"reason\"")
    private String reason ;
     
    /**
     * Pertinent information regarding the current 'value', as free form text.
     */
    public String getRemark () { return remark; }
    public void setRemark ( String remark ) { this.remark = remark; }
    @Basic()
    @Column(name="\"remark\"")
    private String remark ;
     
    /**
     * Status value at 'dateTime'; prior status changes may have been kept in
     * instances of activity records associated with the object to which this
     * status applies.
     */
    public String getValue () { return value; }
    public void setValue ( String value ) { this.value = value; }
    @Basic()
    @Column(name="\"value\"")
    private String value ;
     
    /**
     * A sequence of grouped or atomic steps intended to:
     * - de-energise equipment or part of the network for safe work, and/or
     * - bring back in service previously de-energised equipment or part of the
     * network.
     */
    @Entity
    @Table(name="\"SwitchingPlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingPlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Asset used to perform work.
     */
    @Entity
    @Table(name="\"WorkAsset\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class WorkAsset extends Asset
    {
    }
    /**
     * A task within a set of work.
     */
    @Entity
    @Table(name="\"WorkTask\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WorkTask
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        ActivityRecord.class,
        Analytic.class,
        AnalyticKind.class,
        AnalyticScore.class,
        Asset.class,
        AssetContainer.class,
        AssetDeployment.class,
        AssetHealthEvent.class,
        AssetKind.class,
        AssetLifecycleStateKind.class,
        Crew.class,
        CrewMember.class,
        CrewType.class,
        Equipment.class,
        Fault.class,
        InUseStateKind.class,
        Measurement.class,
        MeasurementValue.class,
        MeasurementValueQuality.class,
        Name.class,
        NameType.class,
        Outage.class,
        Person.class,
        PhaseCode.class,
        ProcedureDataSet.class,
        RetiredReasonKind.class,
        ScaleKind.class,
        SwitchingPlan.class,
        WorkAsset.class,
        WorkTask.class
    };
}
