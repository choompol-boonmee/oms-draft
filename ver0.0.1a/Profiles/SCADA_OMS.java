package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for Profile
 * Generated by CIMTool http://cimtool.org
 */
public class Profile
{
    /**
     * Person who accepted/signed or rejected the document.
     */
    @Entity
    @Table(name="\"Approver\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Approver
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
    /**
     * Person who created document or activity record.
     */
    @Entity
    @Table(name="\"Author\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Author
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
    /**
     * End date and time of this interval. The end date and time where the interval
     * is defined up to, but excluded.
     */
    public String getEnd () { return end; }
    public void setEnd ( String end ) { this.end = end; }
    @Basic()
    @Column(name="\"end\"")
    private String end ;
     
    /**
     * Start date and time of this interval. The start date and time is included
     * in the defined interval.
     */
    public String getStart () { return start; }
    public void setStart ( String start ) { this.start = start; }
    @Basic()
    @Column(name="\"start\"")
    private String start ;
     
    /**
     * Person who issued the document and is responsible for its content.
     */
    @Entity
    @Table(name="\"Issuer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Issuer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
    /**
     * The place, scene, or point of something where someone or something has
     * been, is, and/or will be at a given moment in time. It can be defined with
     * one or more position points (coordinates) in a given coordinate system.
     */
    @Entity
    @Table(name="\"Location\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Location
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * (if applicable) Direction that allows field crews to quickly find a given
         * asset. For a given location, such as a street address, this is the relative
         * direction in which to find the asset. For example, a streetlight may be
         * located at the 'NW' (northwest) corner of the customer's site, or a usage
         * point may be located on the second floor of an apartment building.
         */
        public String getDirection () { return direction; }
        public void setDirection ( String direction ) { this.direction = direction; }
        @Basic()
        @Column(name="\"direction\"")
        private String direction ;
         
    }
    /**
     * Document containing the definition of planned outages of equipment and/or
     * usage points. It will reference switching plans that are used to execute
     * the planned outage.
     */
    @Entity
    @Table(name="\"OutagePlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutagePlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The date and time the outage plan was approved
         */
        public String getApprovedDateTime () { return approvedDateTime; }
        public void setApprovedDateTime ( String approvedDateTime ) { this.approvedDateTime = approvedDateTime; }
        @Basic()
        @Column(name="\"approvedDateTime\"")
        private String approvedDateTime ;
         
        /**
         * Date and Time the planned outage was canceled.
         */
        public String getCancelledDateTime () { return cancelledDateTime; }
        public void setCancelledDateTime ( String cancelledDateTime ) { this.cancelledDateTime = cancelledDateTime; }
        @Basic()
        @Column(name="\"cancelledDateTime\"")
        private String cancelledDateTime ;
         
        /**
         * Purpose of this outage plan, such as whether it is to replace equipment
         * or perform maintenance or repairs or to reconfigure network topology.
         */
        public String getPurpose () { return purpose; }
        public void setPurpose ( String purpose ) { this.purpose = purpose; }
        @Basic()
        @Column(name="\"purpose\"")
        private String purpose ;
         
        /**
         * planned start and end time of the planned outage.
         */
        public DateTimeInterval getPlannedPeriod () { return plannedPeriod; }
        public void setPlannedPeriod ( DateTimeInterval plannedPeriod ) { this.plannedPeriod = plannedPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"plannedPeriod\"")
        private DateTimeInterval plannedPeriod ;
         
    }
    /**
     * General purpose information for name and other information to contact people.
     */
    @Entity
    @Table(name="\"Person\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Person
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Middle name(s) or initial(s).
         */
        public String getMName () { return mName; }
        public void setMName ( String mName ) { this.mName = mName; }
        @Basic()
        @Column(name="\"mName\"")
        private String mName ;
         
    }
     
    /**
     * An unordered enumeration of phase identifiers. Allows designation of phases
     * for both transmission and distribution equipment, circuits and loads. The
     * enumeration, by itself, does not describe how the phases are connected
     * together or connected to ground. Ground is not explicitly denoted as a
     * phase.
     * Residential and small commercial loads are often served from single-phase,
     * or split-phase, secondary circuits. For the example of s12N, phases 1 and
     * 2 refer to hot wires that are 180 degrees out of phase, while N refers
     * to the neutral wire. Through single-phase transformer connections, these
     * secondary circuits may be served from one or two of the primary phases
     * A, B, and C. For three-phase loads, use the A, B, C phase codes instead
     * of s12N.
     * The integer values are from IEC 61968-9 to support revenue metering applications.
     */
    @Entity
    @Table(name="\"PhaseCode\"")
    public static class PhaseCode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Date and time for which status 'value' applies.
     */
    public String getDateTime () { return dateTime; }
    public void setDateTime ( String dateTime ) { this.dateTime = dateTime; }
    @Basic()
    @Column(name="\"dateTime\"")
    private String dateTime ;
     
    /**
     * Reason code or explanation for why an object went to the current status
     * 'value'.
     */
    public String getReason () { return reason; }
    public void setReason ( String reason ) { this.reason = reason; }
    @Basic()
    @Column(name="\"reason\"")
    private String reason ;
     
    /**
     * Pertinent information regarding the current 'value', as free form text.
     */
    public String getRemark () { return remark; }
    public void setRemark ( String remark ) { this.remark = remark; }
    @Basic()
    @Column(name="\"remark\"")
    private String remark ;
     
    /**
     * Status value at 'dateTime'; prior status changes may have been kept in
     * instances of activity records associated with the object to which this
     * status applies.
     */
    public String getValue () { return value; }
    public void setValue ( String value ) { this.value = value; }
    @Basic()
    @Column(name="\"value\"")
    private String value ;
     
    /**
     * A generic device designed to close, or open, or both, one or more electric
     * circuits. All switches are two terminal devices including grounding switches.
     * The ACDCTerminal.connected at the two sides of the switch shall not be
     * considered for assessing switch connectivity, i.e. only Switch.open, .normalOpen
     * and .locked are relevant.
     */
    @Entity
    @Table(name="\"Switch\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Switch
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * The maximum continuous current carrying capacity in amps governed by the
         * device material and construction.
         * The attribute shall be a positive value.
         */
        public Double getRatedCurrent () { return ratedCurrent; }
        public void setRatedCurrent ( Double ratedCurrent ) { this.ratedCurrent = ratedCurrent; }
        @Basic()
        @Column(name="\"ratedCurrent\"")
        private Double ratedCurrent ;
         
        /**
         * The date and time when the switch was last switched on.
         */
        public String getSwitchOnDate () { return switchOnDate; }
        public void setSwitchOnDate ( String switchOnDate ) { this.switchOnDate = switchOnDate; }
        @Basic()
        @Column(name="\"switchOnDate\"")
        private String switchOnDate ;
         
    }
    /**
     * Action on switch as a switching step.
     */
    @Entity
    @Table(name="\"SwitchAction\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class SwitchAction extends SwitchingAction
    {
        /**
         * Switching action to perform.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Switch that is the object of this switch action.
         */
        public Switch getOperatedSwitch () { return operatedSwitch; }
        public void setOperatedSwitch ( Switch operatedSwitch ) { this.operatedSwitch = operatedSwitch; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OperatedSwitch\"")
        private Switch operatedSwitch ;
         
    }
     
    /**
     * Kind of action on switch.
     */
    @Entity
    @Table(name="\"SwitchActionKind\"")
    public static class SwitchActionKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Atomic switching action.
     */
    @Entity
    @Table(name="\"SwitchingAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Actual date and time of this switching step.
         */
        public String getExecutedDateTime () { return executedDateTime; }
        public void setExecutedDateTime ( String executedDateTime ) { this.executedDateTime = executedDateTime; }
        @Basic()
        @Column(name="\"executedDateTime\"")
        private String executedDateTime ;
         
        /**
         * Date and time when the crew was given the instruction to execute the action;
         * not applicable if the action is performed by operator remote control.
         */
        public String getIssuedDateTime () { return issuedDateTime; }
        public void setIssuedDateTime ( String issuedDateTime ) { this.issuedDateTime = issuedDateTime; }
        @Basic()
        @Column(name="\"issuedDateTime\"")
        private String issuedDateTime ;
         
        /**
         * Phases of the Switching Action
         */
        public String getPhases () { return phases; }
        public void setPhases ( String phases ) { this.phases = phases; }
        @Basic()
        @Column(name="\"phases\"")
        private String phases ;
         
        /**
         * Planned date and time of this switching step.
         */
        public String getPlannedDateTime () { return plannedDateTime; }
        public void setPlannedDateTime ( String plannedDateTime ) { this.plannedDateTime = plannedDateTime; }
        @Basic()
        @Column(name="\"plannedDateTime\"")
        private String plannedDateTime ;
         
        /**
         * The switching event that the switching action is performed on
         */
        public SwitchingEvent getSwitchingEvent () { return switchingEvent; }
        public void setSwitchingEvent ( SwitchingEvent switchingEvent ) { this.switchingEvent = switchingEvent; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchingEvent\"")
        private SwitchingEvent switchingEvent ;
         
        /**
         * The switching step that is associated to the switching action.
         */
        public SwitchingStep getSwitchingStep () { return switchingStep; }
        public void setSwitchingStep ( SwitchingStep switchingStep ) { this.switchingStep = switchingStep; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchingStep\"")
        private SwitchingStep switchingStep ;
         
    }
    /**
     * Event indicating the completion (success or fail) of any switching action
     * (jumper action, cut action, tag action, etc). The switching action may
     * or may not be a consequential event in response to a request to complete
     * the action.
     */
    @Entity
    @Table(name="\"SwitchingEvent\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingEvent
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time this activity record has been created (different from the
         * 'status.dateTime', which is the time of a status change of the associated
         * object, if applicable).
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Reason for event resulting in this activity record, typically supplied
         * when user initiated.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Severity level of event resulting in this activity record.
         */
        public String getSeverity () { return severity; }
        public void setSeverity ( String severity ) { this.severity = severity; }
        @Basic()
        @Column(name="\"severity\"")
        private String severity ;
         
        /**
         * Type of event resulting in this activity record.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * Transmits a switching plan to a crew in order for the plan to be executed.
     */
    @Entity
    @Table(name="\"SwitchingOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Name of the author of this document.
         */
        public String getAuthorName () { return authorName; }
        public void setAuthorName ( String authorName ) { this.authorName = authorName; }
        @Basic()
        @Column(name="\"authorName\"")
        private String authorName ;
         
        /**
         * Free-form comment associated with the switching order.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * Revision number for this document.
         */
        public String getRevisionNumber () { return revisionNumber; }
        public void setRevisionNumber ( String revisionNumber ) { this.revisionNumber = revisionNumber; }
        @Basic()
        @Column(name="\"revisionNumber\"")
        private String revisionNumber ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Approver of this document.
         */
        public Approver getApprover () { return approver; }
        public void setApprover ( Approver approver ) { this.approver = approver; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Approver\"")
        private Approver approver ;
         
        /**
         * Author of this document.
         */
        public Author getAuthor () { return author; }
        public void setAuthor ( Author author ) { this.author = author; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Author\"")
        private Author author ;
         
        /**
         * Status of this document. For status of subject matter this document represents
         * (e.g., Agreement, Work), use 'status' attribute.
         * Example values for 'docStatus.status' are draft, approved, cancelled, etc.
         */
        public Status getDocStatus () { return docStatus; }
        public void setDocStatus ( Status docStatus ) { this.docStatus = docStatus; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"docStatus\"")
        private Status docStatus ;
         
        /**
         * Issuer of this document.
         */
        public Issuer getIssuer () { return issuer; }
        public void setIssuer ( Issuer issuer ) { this.issuer = issuer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Issuer\"")
        private Issuer issuer ;
         
        /**
         * The planned start and end time for the switching order.
         */
        public DateTimeInterval getPlannedExecutionInterval () { return plannedExecutionInterval; }
        public void setPlannedExecutionInterval ( DateTimeInterval plannedExecutionInterval ) { this.plannedExecutionInterval = plannedExecutionInterval; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"plannedExecutionInterval\"")
        private DateTimeInterval plannedExecutionInterval ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
        /**
         * The switching plan that is defined in the switching order.
         */
        public SwitchingPlan getSwitchingPlan () { return switchingPlan; }
        public void setSwitchingPlan ( SwitchingPlan switchingPlan ) { this.switchingPlan = switchingPlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchingPlan\"")
        private SwitchingPlan switchingPlan ;
         
    }
    /**
     * A sequence of grouped or atomic steps intended to:
     * - de-energise equipment or part of the network for safe work, and/or
     * - bring back in service previously de-energised equipment or part of the
     * network.
     */
    @Entity
    @Table(name="\"SwitchingPlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingPlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The date and time the switching plan was approved
         */
        public String getApprovedDateTime () { return approvedDateTime; }
        public void setApprovedDateTime ( String approvedDateTime ) { this.approvedDateTime = approvedDateTime; }
        @Basic()
        @Column(name="\"approvedDateTime\"")
        private String approvedDateTime ;
         
        /**
         * Date and Time the switching plan was cancelled.
         */
        public String getCancelledDateTime () { return cancelledDateTime; }
        public void setCancelledDateTime ( String cancelledDateTime ) { this.cancelledDateTime = cancelledDateTime; }
        @Basic()
        @Column(name="\"cancelledDateTime\"")
        private String cancelledDateTime ;
         
        /**
         * Purpose of this plan, such as whether it is to move the state from normal
         * to some abnormal condition, or to restore the normal state after an abnormal
         * condition, or to perform some kind of optimisation such as correction of
         * overload, voltage control, etc.
         */
        public String getPurpose () { return purpose; }
        public void setPurpose ( String purpose ) { this.purpose = purpose; }
        @Basic()
        @Column(name="\"purpose\"")
        private String purpose ;
         
        /**
         * The outage plan for which the switching plan is defined.
         */
        public OutagePlan getOutagePlan () { return outagePlan; }
        public void setOutagePlan ( OutagePlan outagePlan ) { this.outagePlan = outagePlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OutagePlan\"")
        private OutagePlan outagePlan ;
         
        /**
         * the planned start and end times for the switching plan.
         */
        public DateTimeInterval getPlannedPeriod () { return plannedPeriod; }
        public void setPlannedPeriod ( DateTimeInterval plannedPeriod ) { this.plannedPeriod = plannedPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"plannedPeriod\"")
        private DateTimeInterval plannedPeriod ;
         
    }
    /**
     * Atomic switching step; can be part of a switching step group, or part of
     * a switching plan.
     */
    @Entity
    @Table(name="\"SwitchingStep\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingStep
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        Approver.class,
        Author.class,
        Issuer.class,
        Location.class,
        OutagePlan.class,
        Person.class,
        PhaseCode.class,
        Switch.class,
        SwitchAction.class,
        SwitchActionKind.class,
        SwitchingAction.class,
        SwitchingEvent.class,
        SwitchingOrder.class,
        SwitchingPlan.class,
        SwitchingStep.class
    };
}
