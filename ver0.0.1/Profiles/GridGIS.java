package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for Profile
 * Generated by CIMTool http://cimtool.org
 */
public class Profile
{
    /**
     * A wire or combination of wires, with consistent electrical characteristics,
     * building a single electrical system, used to carry alternating current
     * between points in the power system.
     * For symmetrical, transposed three phase lines, it is sufficient to use
     * attributes of the line segment, which describe impedances and admittances
     * for the entire length of the segment. Additionally impedances can be computed
     * by using length and associated per length impedances.
     * The BaseVoltage at the two ends of ACLineSegments in a Line shall have
     * the same BaseVoltage.nominalVoltage. However, boundary lines may have slightly
     * different BaseVoltage.nominalVoltages and variation is allowed. Larger
     * voltage difference in general requires use of an equivalent branch.
     */
    @Entity
    @Table(name="\"ACLineSegment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ACLineSegment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Segment length for calculating line section capabilities.
         */
        public Double getLength () { return length; }
        public void setLength ( Double length ) { this.length = length; }
        @Basic()
        @Column(name="\"length\"")
        private Double length ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Positive sequence series resistance of the entire line section.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Positive sequence series reactance of the entire line section.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * Represents a single wire of an alternating current line segment.
     */
    @Entity
    @Table(name="\"ACLineSegmentPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ACLineSegmentPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The phase connection of the wire at both ends.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * Number designation for this line segment phase. Each line segment phase
         * within a line segment should have a unique sequence number. This is useful
         * for unbalanced modelling to bind the mathematical model (PhaseImpedanceData
         * of PerLengthPhaseImpedance) with the connectivity model (this class) and
         * the physical model (WirePosition) without tight coupling.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
    }
    /**
     * Defines a system base voltage which is referenced.
     */
    @Entity
    @Table(name="\"BaseVoltage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class BaseVoltage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The power system resource's base voltage. Shall be a positive value and
         * not zero.
         */
        public Double getNominalVoltage () { return nominalVoltage; }
        public void setNominalVoltage ( Double nominalVoltage ) { this.nominalVoltage = nominalVoltage; }
        @Basic()
        @Column(name="\"nominalVoltage\"")
        private Double nominalVoltage ;
         
    }
    /**
     * A mechanical switching device capable of making, carrying, and breaking
     * currents under normal circuit conditions and also making, carrying for
     * a specified time, and breaking currents under specified abnormal circuit
     * conditions e.g. those of short circuit.
     */
    @Entity
    @Table(name="\"Breaker\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Breaker
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The maximum fault current a breaking device can break safely under prescribed
         * conditions of use.
         */
        public Double getBreakingCapacity () { return breakingCapacity; }
        public void setBreakingCapacity ( Double breakingCapacity ) { this.breakingCapacity = breakingCapacity; }
        @Basic()
        @Column(name="\"breakingCapacity\"")
        private Double breakingCapacity ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A conductor, or group of conductors, with negligible impedance, that serve
     * to connect other conducting equipment within a single substation.
     * Voltage measurements are typically obtained from voltage transformers that
     * are connected to busbar sections. A bus bar section may have many physical
     * terminals but for analysis is modelled with exactly one logical terminal.
     */
    @Entity
    @Table(name="\"BusbarSection\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class BusbarSection
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * Connectivity nodes are points where terminals of AC conducting equipment
     * are connected together with zero impedance.
     */
    @Entity
    @Table(name="\"ConnectivityNode\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ConnectivityNode
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Coordinate reference system.
     */
    @Entity
    @Table(name="\"CoordinateSystem\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CoordinateSystem
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A Uniform Resource Name (URN) for the coordinate reference system (crs)
         * used to define 'Location.PositionPoints'.
         * An example would be the European Petroleum Survey Group (EPSG) code for
         * a coordinate reference system, defined in URN under the Open Geospatial
         * Consortium (OGC) namespace as: urn:ogc:def:crs:EPSG::XXXX, where XXXX is
         * an EPSG code (a full list of codes can be found at the EPSG Registry web
         * site http://www.epsg-registry.org/). To define the coordinate system as
         * being WGS84 (latitude, longitude) using an EPSG OGC, this attribute would
         * be urn:ogc:def:crs:EPSG::4.3.2.6
         * A profile should limit this code to a set of allowed URNs agreed to by
         * all sending and receiving parties.
         */
        public String getCrsUrn () { return crsUrn; }
        public void setCrsUrn ( String crsUrn ) { this.crsUrn = crsUrn; }
        @Basic()
        @Column(name="\"crsUrn\"")
        private String crsUrn ;
         
    }
    /**
     * Organisation receiving services from service supplier.
     */
    @Entity
    @Table(name="\"Customer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Customer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Assignment of a group of products and services purchased by the customer
     * through a customer agreement, used as a mechanism for customer billing
     * and payment. It contains common information from the various types of customer
     * agreements to create billings (invoices) for a customer and receive payment.
     */
    @Entity
    @Table(name="\"CustomerAccount\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CustomerAccount
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Status of subject matter (e.g., Agreement, Work) this document represents.
         * For status of the document itself, use 'docStatus' attribute.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
    }
    /**
     * A manually operated or motor operated mechanical switching device used
     * for changing the connections in a circuit, or for isolating a circuit or
     * equipment from a source of power. It is required to open or close circuits
     * when negligible current is broken or made.
     */
    @Entity
    @Table(name="\"Disconnector\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Disconnector extends Switch
    {
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * Branch is retained in the topological solution. The flow through retained
         * switches will normally be calculated in power flow.
         */
        public Boolean getRetained () { return retained; }
        public void setRetained ( Boolean retained ) { this.retained = retained; }
        @Basic()
        @Column(name="\"retained\"")
        private Boolean retained ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A connection of energy generation or consumption on the power system model.
     */
    @Entity
    @Table(name="\"EnergyConnection\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergyConnection
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A generic equivalent for an energy supplier on a transmission or distribution
     * voltage level.
     */
    @Entity
    @Table(name="\"EnergySource\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class EnergySource extends EnergyConnection
    {
        /**
         * High voltage source active injection. Load sign convention is used, i.e.
         * positive sign means flow out from a node.
         * Starting value for steady state solutions.
         */
        public Double getActivePower () { return activePower; }
        public void setActivePower ( Double activePower ) { this.activePower = activePower; }
        @Basic()
        @Column(name="\"activePower\"")
        private Double activePower ;
         
        /**
         * High voltage source reactive injection. Load sign convention is used, i.e.
         * positive sign means flow out from a node.
         * Starting value for steady state solutions.
         */
        public Double getReactivePower () { return reactivePower; }
        public void setReactivePower ( Double reactivePower ) { this.reactivePower = reactivePower; }
        @Basic()
        @Column(name="\"reactivePower\"")
        private Double reactivePower ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * The parts of a power system that are physical devices, electronic or mechanical.
     */
    @Entity
    @Table(name="\"Equipment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Equipment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * A modelling construct to provide a root class for containing equipment.
     */
    @Entity
    @Table(name="\"EquipmentContainer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EquipmentContainer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * An overcurrent protective device with a circuit opening fusible part that
     * is heated and severed by the passage of overcurrent through it. A fuse
     * is considered a switching device because it breaks current.
     */
    @Entity
    @Table(name="\"Fuse\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Fuse extends Switch
    {
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * Branch is retained in the topological solution. The flow through retained
         * switches will normally be calculated in power flow.
         */
        public Boolean getRetained () { return retained; }
        public void setRetained ( Boolean retained ) { this.retained = retained; }
        @Basic()
        @Column(name="\"retained\"")
        private Boolean retained ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A geographical region of a power system network model.
     */
    @Entity
    @Table(name="\"GeographicalRegion\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GeographicalRegion
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * The place, scene, or point of something where someone or something has
     * been, is, and/or will be at a given moment in time. It can be defined with
     * one or more position points (coordinates) in a given coordinate system.
     */
    @Entity
    @Table(name="\"Location\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Location
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Coordinate system used to describe position points of this location.
         */
        public CoordinateSystem getCoordinateSystem () { return coordinateSystem; }
        public void setCoordinateSystem ( CoordinateSystem coordinateSystem ) { this.coordinateSystem = coordinateSystem; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CoordinateSystem\"")
        private CoordinateSystem coordinateSystem ;
         
    }
    /**
     * Physical asset that performs the metering role of the usage point. Used
     * for measuring consumption and detection of events.
     */
    @Entity
    @Table(name="\"Meter\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Meter
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Customer owning this end device.
         */
        public Customer getCustomer () { return customer; }
        public void setCustomer ( Customer customer ) { this.customer = customer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Customer\"")
        private Customer customer ;
         
        /**
         */
        public Name getName () { return name; }
        public void setName ( Name name ) { this.name = name; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Name\"")
        private Name name ;
         
        /**
         */
        public Name getName () { return name; }
        public void setName ( Name name ) { this.name = name; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Name\"")
        private Name name ;
         
        /**
         */
        public Name getName () { return name; }
        public void setName ( Name name ) { this.name = name; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Name\"")
        private Name name ;
         
        /**
         */
        public Name getName () { return name; }
        public void setName ( Name name ) { this.name = name; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Name\"")
        private Name name ;
         
        /**
         */
        public Name getName () { return name; }
        public void setName ( Name name ) { this.name = name; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Name\"")
        private Name name ;
         
        /**
         */
        public Name getName () { return name; }
        public void setName ( Name name ) { this.name = name; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Name\"")
        private Name name ;
         
        /**
         * Usage point to which this end device belongs.
         */
        public UsagePoint getUsagePoint () { return usagePoint; }
        public void setUsagePoint ( UsagePoint usagePoint ) { this.usagePoint = usagePoint; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"UsagePoint\"")
        private UsagePoint usagePoint ;
         
    }
    /**
     * The Name class provides the means to define any number of human readable
     * names for an object. A name is <b>not</b> to be used for defining inter-object
     * relationships. For inter-object relationships instead use the object identification
     * 'mRID'.
     */
    @Entity
    @Table(name="\"Name\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Name
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Any free text that name the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Type of this name.
         */
        public NameType getNameType () { return nameType; }
        public void setNameType ( NameType nameType ) { this.nameType = nameType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"NameType\"")
        private NameType nameType ;
         
    }
    /**
     * General purpose information for name and other information to contact people.
     */
    @Entity
    @Table(name="\"Person\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Person
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Middle name(s) or initial(s).
         */
        public String getMName () { return mName; }
        public void setMName ( String mName ) { this.mName = mName; }
        @Basic()
        @Column(name="\"mName\"")
        private String mName ;
         
        /**
         * Electronic address.
         */
        public ElectronicAddress getElectronicAddress () { return electronicAddress; }
        public void setElectronicAddress ( ElectronicAddress electronicAddress ) { this.electronicAddress = electronicAddress; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"electronicAddress\"")
        private ElectronicAddress electronicAddress ;
         
        /**
         * Landline phone number.
         */
        public TelephoneNumber getLandlinePhone () { return landlinePhone; }
        public void setLandlinePhone ( TelephoneNumber landlinePhone ) { this.landlinePhone = landlinePhone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"landlinePhone\"")
        private TelephoneNumber landlinePhone ;
         
        /**
         * Mobile phone number.
         */
        public TelephoneNumber getMobilePhone () { return mobilePhone; }
        public void setMobilePhone ( TelephoneNumber mobilePhone ) { this.mobilePhone = mobilePhone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"mobilePhone\"")
        private TelephoneNumber mobilePhone ;
         
    }
     
    /**
     * An unordered enumeration of phase identifiers. Allows designation of phases
     * for both transmission and distribution equipment, circuits and loads. The
     * enumeration, by itself, does not describe how the phases are connected
     * together or connected to ground. Ground is not explicitly denoted as a
     * phase.
     * Residential and small commercial loads are often served from single-phase,
     * or split-phase, secondary circuits. For the example of s12N, phases 1 and
     * 2 refer to hot wires that are 180 degrees out of phase, while N refers
     * to the neutral wire. Through single-phase transformer connections, these
     * secondary circuits may be served from one or two of the primary phases
     * A, B, and C. For three-phase loads, use the A, B, C phase codes instead
     * of s12N.
     * The integer values are from IEC 61968-9 to support revenue metering applications.
     */
    @Entity
    @Table(name="\"PhaseCode\"")
    public static class PhaseCode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Set of spatial coordinates that determine a point, defined in the coordinate
     * system specified in 'Location.CoordinateSystem'. Use a single position
     * point instance to describe a point-oriented location. Use a sequence of
     * position points to describe a line-oriented object (physical location of
     * non-point oriented objects like cables or lines), or area of an object
     * (like a substation or a geographical zone - in this case, have first and
     * last position point with the same values).
     */
    @Entity
    @Table(name="\"PositionPoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PositionPoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Zero-relative sequence number of this point within a series of points.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
        /**
         * X axis position.
         */
        public String getXPosition () { return xPosition; }
        public void setXPosition ( String xPosition ) { this.xPosition = xPosition; }
        @Basic()
        @Column(name="\"xPosition\"")
        private String xPosition ;
         
        /**
         * Y axis position.
         */
        public String getYPosition () { return yPosition; }
        public void setYPosition ( String yPosition ) { this.yPosition = yPosition; }
        @Basic()
        @Column(name="\"yPosition\"")
        private String yPosition ;
         
    }
    /**
     * An electrical device consisting of two or more coupled windings, with or
     * without a magnetic core, for introducing mutual coupling between electric
     * circuits. Transformers can be used to control voltage and phase shift (active
     * power flow).
     * A power transformer may be composed of separate transformer tanks that
     * need not be identical.
     * A power transformer can be modelled with or without tanks and is intended
     * for use in both balanced and unbalanced representations. A power transformer
     * typically has two terminals, but may have one (grounding), three or more
     * terminals.
     * The inherited association ConductingEquipment.BaseVoltage should not be
     * used. The association from TransformerEnd to BaseVoltage should be used
     * instead.
     */
    @Entity
    @Table(name="\"PowerTransformer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerTransformer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A PowerTransformerEnd is associated with each Terminal of a PowerTransformer.
     * The impedance values r, r0, x, and x0 of a PowerTransformerEnd represents
     * a star equivalent as follows.
     * 1) for a two Terminal PowerTransformer the high voltage (TransformerEnd.endNumber=1)
     * PowerTransformerEnd has non zero values on r, r0, x, and x0 while the low
     * voltage (TransformerEnd.endNumber=2) PowerTransformerEnd has zero values
     * for r, r0, x, and x0. Parameters are always provided, even if the PowerTransformerEnds
     * have the same rated voltage. In this case, the parameters are provided
     * at the PowerTransformerEnd which has TransformerEnd.endNumber equal to
     * 1.
     * 2) for a three Terminal PowerTransformer the three PowerTransformerEnds
     * represent a star equivalent with each leg in the star represented by r,
     * r0, x, and x0 values.
     * 3) For a three Terminal transformer each PowerTransformerEnd shall have
     * g, g0, b and b0 values corresponding to the no load losses distributed
     * on the three PowerTransformerEnds. The total no load loss shunt impedances
     * may also be placed at one of the PowerTransformerEnds, preferably the end
     * numbered 1, having the shunt values on end 1. This is the preferred way.
     * 4) for a PowerTransformer with more than three Terminals the PowerTransformerEnd
     * impedance values cannot be used. Instead use the TransformerMeshImpedance
     * or split the transformer into multiple PowerTransformers.
     * Each PowerTransformerEnd must be contained by a PowerTransformer. Because
     * a PowerTransformerEnd (or any other object) can not be contained by more
     * than one parent, a PowerTransformerEnd can not have an association to an
     * EquipmentContainer (Substation, VoltageLevel, etc).
     */
    @Entity
    @Table(name="\"PowerTransformerEnd\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerTransformerEnd
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The power transformer of this power transformer end.
         */
        public PowerTransformer getPowerTransformer () { return powerTransformer; }
        public void setPowerTransformer ( PowerTransformer powerTransformer ) { this.powerTransformer = powerTransformer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerTransformer\"")
        private PowerTransformer powerTransformer ;
         
        /**
         * Terminal of the power transformer to which this transformer end belongs.
         */
        public Terminal getTerminal () { return terminal; }
        public void setTerminal ( Terminal terminal ) { this.terminal = terminal; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Terminal\"")
        private Terminal terminal ;
         
    }
    /**
     * Pole-mounted fault interrupter with built-in phase and ground relays, current
     * transformer (CT), and supplemental controls.
     */
    @Entity
    @Table(name="\"Recloser\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Recloser
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The maximum fault current a breaking device can break safely under prescribed
         * conditions of use.
         */
        public Double getBreakingCapacity () { return breakingCapacity; }
        public void setBreakingCapacity ( Double breakingCapacity ) { this.breakingCapacity = breakingCapacity; }
        @Basic()
        @Column(name="\"breakingCapacity\"")
        private Double breakingCapacity ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A type of conducting equipment that can regulate a quantity (i.e. voltage
     * or flow) at a specific point in the network.
     */
    @Entity
    @Table(name="\"RegulatingCondEq\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class RegulatingCondEq extends EnergyConnection
    {
        /**
         * Specifies the regulation status of the equipment. True is regulating, false
         * is not regulating.
         */
        public Boolean getControlEnabled () { return controlEnabled; }
        public void setControlEnabled ( Boolean controlEnabled ) { this.controlEnabled = controlEnabled; }
        @Basic()
        @Column(name="\"controlEnabled\"")
        private Boolean controlEnabled ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
        /**
         * The regulating control scheme in which this equipment participates.
         */
        public RegulatingControl getRegulatingControl () { return regulatingControl; }
        public void setRegulatingControl ( RegulatingControl regulatingControl ) { this.regulatingControl = regulatingControl; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RegulatingControl\"")
        private RegulatingControl regulatingControl ;
         
    }
    /**
     * Specifies a set of equipment that works together to control a power system
     * quantity such as voltage or flow.
     * Remote bus voltage control is possible by specifying the controlled terminal
     * located at some place remote from the controlling equipment.
     * The specified terminal shall be associated with the connectivity node of
     * the controlled point. The most specific subtype of RegulatingControl shall
     * be used in case such equipment participate in the control, e.g. TapChangerControl
     * for tap changers.
     * For flow control, load sign convention is used, i.e. positive sign means
     * flow out from a TopologicalNode (bus) into the conducting equipment.
     * The attribute minAllowedTargetValue and maxAllowedTargetValue are required
     * in the following cases:
     * - For a power generating module operated in power factor control mode to
     * specify maximum and minimum power factor values;
     * - Whenever it is necessary to have an off center target voltage for the
     * tap changer regulator. For instance, due to long cables to off shore wind
     * farms and the need to have a simpler setup at the off shore transformer
     * platform, the voltage is controlled from the land at the connection point
     * for the off shore wind farm. Since there usually is a voltage rise along
     * the cable, there is typical and overvoltage of up 3-4 kV compared to the
     * on shore station. Thus in normal operation the tap changer on the on shore
     * station is operated with a target set point, which is in the lower parts
     * of the dead band.
     * The attributes minAllowedTargetValue and maxAllowedTargetValue are not
     * related to the attribute targetDeadband and thus they are not treated as
     * an alternative of the targetDeadband. They are needed due to limitations
     * in the local substation controller. The attribute targetDeadband is used
     * to prevent the power flow from move the tap position in circles (hunting)
     * that is to be used regardless of the attributes minAllowedTargetValue and
     * maxAllowedTargetValue.
     */
    @Entity
    @Table(name="\"RegulatingControl\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RegulatingControl
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The regulation is performed in a discrete mode. This applies to equipment
         * with discrete controls, e.g. tap changers and shunt compensators.
         */
        public Boolean getDiscrete () { return discrete; }
        public void setDiscrete ( Boolean discrete ) { this.discrete = discrete; }
        @Basic()
        @Column(name="\"discrete\"")
        private Boolean discrete ;
         
        /**
         * The flag tells if regulation is enabled.
         */
        public Boolean getEnabled () { return enabled; }
        public void setEnabled ( Boolean enabled ) { this.enabled = enabled; }
        @Basic()
        @Column(name="\"enabled\"")
        private Boolean enabled ;
         
    }
     
    /**
     * Enumeration of single phase identifiers. Allows designation of single phases
     * for both transmission and distribution equipment, circuits and loads.
     */
    @Entity
    @Table(name="\"SinglePhaseKind\"")
    public static class SinglePhaseKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A subset of a geographical region of a power system network model.
     */
    @Entity
    @Table(name="\"SubGeographicalRegion\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SubGeographicalRegion
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The geographical region which this sub-geographical region is within.
         */
        public GeographicalRegion getRegion () { return region; }
        public void setRegion ( GeographicalRegion region ) { this.region = region; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Region\"")
        private GeographicalRegion region ;
         
    }
    /**
     * A collection of equipment for purposes other than generation or utilization,
     * through which electric energy in bulk is passed for the purposes of switching
     * or modifying its characteristics.
     */
    @Entity
    @Table(name="\"Substation\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Substation extends EquipmentContainer
    {
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A generic device designed to close, or open, or both, one or more electric
     * circuits. All switches are two terminal devices including grounding switches.
     * The ACDCTerminal.connected at the two sides of the switch shall not be
     * considered for assessing switch connectivity, i.e. only Switch.open, .normalOpen
     * and .locked are relevant.
     */
    @Entity
    @Table(name="\"Switch\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Switch
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * Main (local) part of this telephone number.
     */
    public String getLocalNumber () { return localNumber; }
    public void setLocalNumber ( String localNumber ) { this.localNumber = localNumber; }
    @Basic()
    @Column(name="\"localNumber\"")
    private String localNumber ;
     
    /**
     * An AC electrical connection point to a piece of conducting equipment. Terminals
     * are connected at physical connection points called connectivity nodes.
     */
    @Entity
    @Table(name="\"Terminal\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Terminal
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Represents the normal network phasing condition. If the attribute is missing,
         * three phases (ABC) shall be assumed, except for terminals of grounding
         * classes (specializations of EarthFaultCompensator, GroundDisconnector,
         * and Ground) which will be assumed to be N. Therefore, phase code ABCN is
         * explicitly declared when needed, e.g. for star point grounding equipment.
         * The phase code on terminals connecting same ConnectivityNode or same TopologicalNode
         * as well as for equipment between two terminals shall be consistent.
         */
        public String getPhases () { return phases; }
        public void setPhases ( String phases ) { this.phases = phases; }
        @Basic()
        @Column(name="\"phases\"")
        private String phases ;
         
        /**
         * The connectivity node to which this terminal connects with zero impedance.
         */
        public ConnectivityNode getConnectivityNode () { return connectivityNode; }
        public void setConnectivityNode ( ConnectivityNode connectivityNode ) { this.connectivityNode = connectivityNode; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ConnectivityNode\"")
        private ConnectivityNode connectivityNode ;
         
    }
     
    /**
     * The unit multipliers defined for the CIM. When applied to unit symbols,
     * the unit symbol is treated as a derived unit. Regardless of the contents
     * of the unit symbol text, the unit symbol shall be treated as if it were
     * a single-character unit symbol. Unit symbols should not contain multipliers,
     * and it should be left to the multiplier to define the multiple for an entire
     * data type.
     * For example, if a unit symbol is "m2Pers" and the multiplier is "k", then
     * the value is k(m**2/s), and the multiplier applies to the entire final
     * value, not to any individual part of the value. This can be conceptualized
     * by substituting a derived unit symbol for the unit type. If one imagines
     * that the symbol "" represents the derived unit "m2Pers", then applying
     * the multiplier "k" can be conceptualized simply as "k".
     * For example, the SI unit for mass is "kg" and not "g". If the unit symbol
     * is defined as "kg", then the multiplier is applied to "kg" as a whole and
     * does not replace the "k" in front of the "g". In this case, the multiplier
     * of "m" would be used with the unit symbol of "kg" to represent one gram.
     * As a text string, this violates the instructions in IEC 80000-1. However,
     * because the unit symbol in CIM is treated as a derived unit instead of
     * as an SI unit, it makes more sense to conceptualize the "kg" as if it were
     * replaced by one of the proposed replacements for the SI mass symbol. If
     * one imagines that the "kg" were replaced by a symbol "", then it is easier
     * to conceptualize the multiplier "m" as creating the proper unit "m", and
     * not the forbidden unit "mkg".
     */
    @Entity
    @Table(name="\"UnitMultiplier\"")
    public static class UnitMultiplier
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Logical or physical point in the network to which readings or events may
     * be attributed. Used at the place where a physical or virtual meter may
     * be located; however, it is not required that a meter be present.
     */
    @Entity
    @Table(name="\"UsagePoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class UsagePoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
    }
    /**
     * A collection of equipment at one common system voltage forming a switchgear.
     * The equipment typically consists of breakers, busbars, instrumentation,
     * control, regulation and protection devices as well as assemblies of all
     * these.
     */
    @Entity
    @Table(name="\"VoltageLevel\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class VoltageLevel extends EquipmentContainer
    {
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The base voltage used for all equipment within the voltage level.
         */
        public BaseVoltage getBaseVoltage () { return baseVoltage; }
        public void setBaseVoltage ( BaseVoltage baseVoltage ) { this.baseVoltage = baseVoltage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"BaseVoltage\"")
        private BaseVoltage baseVoltage ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        ACLineSegment.class,
        ACLineSegmentPhase.class,
        BaseVoltage.class,
        Breaker.class,
        BusbarSection.class,
        ConnectivityNode.class,
        CoordinateSystem.class,
        Customer.class,
        CustomerAccount.class,
        Disconnector.class,
        EnergyConnection.class,
        EnergySource.class,
        Equipment.class,
        EquipmentContainer.class,
        Fuse.class,
        GeographicalRegion.class,
        Location.class,
        Meter.class,
        Name.class,
        Person.class,
        PhaseCode.class,
        PositionPoint.class,
        PowerTransformer.class,
        PowerTransformerEnd.class,
        Recloser.class,
        RegulatingCondEq.class,
        RegulatingControl.class,
        SinglePhaseKind.class,
        SubGeographicalRegion.class,
        Substation.class,
        Switch.class,
        Terminal.class,
        UnitMultiplier.class,
        UsagePoint.class,
        VoltageLevel.class
    };
}
