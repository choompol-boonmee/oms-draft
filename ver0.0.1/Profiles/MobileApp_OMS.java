package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for MobileApp_OMS_Profile
 * Generated by CIMTool http://cimtool.org
 */
public class MobileApp_OMS_Profile
{
    /**
     * Coordinate reference system.
     */
    @Entity
    @Table(name="\"CoordinateSystem\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CoordinateSystem
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A Uniform Resource Name (URN) for the coordinate reference system (crs)
         * used to define 'Location.PositionPoints'.
         * An example would be the European Petroleum Survey Group (EPSG) code for
         * a coordinate reference system, defined in URN under the Open Geospatial
         * Consortium (OGC) namespace as: urn:ogc:def:crs:EPSG::XXXX, where XXXX is
         * an EPSG code (a full list of codes can be found at the EPSG Registry web
         * site http://www.epsg-registry.org/). To define the coordinate system as
         * being WGS84 (latitude, longitude) using an EPSG OGC, this attribute would
         * be urn:ogc:def:crs:EPSG::4.3.2.6
         * A profile should limit this code to a set of allowed URNs agreed to by
         * all sending and receiving parties.
         */
        public String getCrsUrn () { return crsUrn; }
        public void setCrsUrn ( String crsUrn ) { this.crsUrn = crsUrn; }
        @Basic()
        @Column(name="\"crsUrn\"")
        private String crsUrn ;
         
    }
    /**
     * Group of people with specific skills, tools, and vehicles.
     */
    @Entity
    @Table(name="\"Crew\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Crew
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Type of this crew.
         */
        public CrewType getCrewType () { return crewType; }
        public void setCrewType ( CrewType crewType ) { this.crewType = crewType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CrewType\"")
        private CrewType crewType ;
         
        /**
         * Status of this crew.
         */
        public Status getStatus () { return status; }
        public void setStatus ( Status status ) { this.status = status; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"status\"")
        private Status status ;
         
        /**
         * The switching action that is assigned to this crew.
         */
        public SwitchingAction getSwitchingAction () { return switchingAction; }
        public void setSwitchingAction ( SwitchingAction switchingAction ) { this.switchingAction = switchingAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchingAction\"")
        private SwitchingAction switchingAction ;
         
    }
    /**
     * Member of a crew.
     */
    @Entity
    @Table(name="\"CrewMember\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CrewMember
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Person having this role.
         */
        public Person getPerson () { return person; }
        public void setPerson ( Person person ) { this.person = person; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Person\"")
        private Person person ;
         
    }
     
    /**
     * Defines the current status of the Crew - assigned, arrived, etc.
     */
    @Entity
    @Table(name="\"CrewStatusKind\"")
    public static class CrewStatusKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Custom description of the type of crew. This may be used to determine the
     * type of work the crew can be assigned to. Examples include repair, tree
     * trimming, switching, etc.
     */
    @Entity
    @Table(name="\"CrewType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CrewType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * End date and time of this interval. The end date and time where the interval
     * is defined up to, but excluded.
     */
    public String getEnd () { return end; }
    public void setEnd ( String end ) { this.end = end; }
    @Basic()
    @Column(name="\"end\"")
    private String end ;
     
    /**
     * Start date and time of this interval. The start date and time is included
     * in the defined interval.
     */
    public String getStart () { return start; }
    public void setStart ( String start ) { this.start = start; }
    @Basic()
    @Column(name="\"start\"")
    private String start ;
     
    /**
     * A logical part of the design (e.g., pole and all equipment on a pole).
     * This includes points and spans.
     */
    @Entity
    @Table(name="\"DesignLocation\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class DesignLocation
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Description of a problem in the field that may be reported in a trouble
     * ticket or come from another source. It may have to do with an outage.
     */
    @Entity
    @Table(name="\"Incident\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Incident
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * Cause of this incident.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic()
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * The place, scene, or point of something where someone or something has
     * been, is, and/or will be at a given moment in time. It can be defined with
     * one or more position points (coordinates) in a given coordinate system.
     */
    @Entity
    @Table(name="\"Location\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Location
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * (if applicable) Direction that allows field crews to quickly find a given
         * asset. For a given location, such as a street address, this is the relative
         * direction in which to find the asset. For example, a streetlight may be
         * located at the 'NW' (northwest) corner of the customer's site, or a usage
         * point may be located on the second floor of an apartment building.
         */
        public String getDirection () { return direction; }
        public void setDirection ( String direction ) { this.direction = direction; }
        @Basic()
        @Column(name="\"direction\"")
        private String direction ;
         
        /**
         * (if applicable) Reference to geographical information source, often external
         * to the utility.
         */
        public String getGeoInfoReference () { return geoInfoReference; }
        public void setGeoInfoReference ( String geoInfoReference ) { this.geoInfoReference = geoInfoReference; }
        @Basic()
        @Column(name="\"geoInfoReference\"")
        private String geoInfoReference ;
         
        /**
         * Classification by utility's corporate standards and practices, relative
         * to the location itself (e.g., geographical, functional accounting, etc.,
         * not a given property that happens to exist at that location).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Coordinate system used to describe position points of this location.
         */
        public CoordinateSystem getCoordinateSystem () { return coordinateSystem; }
        public void setCoordinateSystem ( CoordinateSystem coordinateSystem ) { this.coordinateSystem = coordinateSystem; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CoordinateSystem\"")
        private CoordinateSystem coordinateSystem ;
         
    }
    /**
     * Document describing details of an active or planned outage in a part of
     * the electrical network.
     * A non-planned outage may be created upon:
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     * A planned outage may be created upon:
     * - a request for service, maintenance or construction work in the field,
     * or
     * - an operator-defined outage for what-if/contingency network analysis.
     */
    @Entity
    @Table(name="\"Outage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Outage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * a name to denote the community - this could be a name or a code of some
         * kind.
         */
        public String getCommunityDescriptor () { return communityDescriptor; }
        public void setCommunityDescriptor ( String communityDescriptor ) { this.communityDescriptor = communityDescriptor; }
        @Basic()
        @Column(name="\"communityDescriptor\"")
        private String communityDescriptor ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * the total number of customers that are served in the area (both outaged
         * and not outaged).
         */
        public Integer getOriginalCustomersServed () { return originalCustomersServed; }
        public void setOriginalCustomersServed ( Integer originalCustomersServed ) { this.originalCustomersServed = originalCustomersServed; }
        @Basic()
        @Column(name="\"originalCustomersServed\"")
        private Integer originalCustomersServed ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public String getOutageKind () { return outageKind; }
        public void setOutageKind ( String outageKind ) { this.outageKind = outageKind; }
        @Basic()
        @Column(name="\"outageKind\"")
        private String outageKind ;
         
        /**
         * Revision number for this document.
         */
        public String getRevisionNumber () { return revisionNumber; }
        public void setRevisionNumber ( String revisionNumber ) { this.revisionNumber = revisionNumber; }
        @Basic()
        @Column(name="\"revisionNumber\"")
        private String revisionNumber ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public String getStatusKind () { return statusKind; }
        public void setStatusKind ( String statusKind ) { this.statusKind = statusKind; }
        @Basic()
        @Column(name="\"statusKind\"")
        private String statusKind ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * This contains an disclaimers the utility would like to place on the data
         * provided to any stakeholder. This may be different for different stakeholders.
         * This should possibly be an attribute under the Organization class but it
         * is placed here for now.
         */
        public String getUtilityDisclaimer () { return utilityDisclaimer; }
        public void setUtilityDisclaimer ( String utilityDisclaimer ) { this.utilityDisclaimer = utilityDisclaimer; }
        @Basic()
        @Column(name="\"utilityDisclaimer\"")
        private String utilityDisclaimer ;
         
        /**
         * Actual outage period; end of the period corresponds to the actual restoration
         * time.
         */
        public DateTimeInterval getActualPeriod () { return actualPeriod; }
        public void setActualPeriod ( DateTimeInterval actualPeriod ) { this.actualPeriod = actualPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"actualPeriod\"")
        private DateTimeInterval actualPeriod ;
         
        /**
         * Estimated outage period for a planned outage. The start of the period is
         * the start of the planned outage and the end of the period corresponds to
         * the end of the planned outage.
         */
        public DateTimeInterval getEstimatedPeriod () { return estimatedPeriod; }
        public void setEstimatedPeriod ( DateTimeInterval estimatedPeriod ) { this.estimatedPeriod = estimatedPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"estimatedPeriod\"")
        private DateTimeInterval estimatedPeriod ;
         
        /**
         * The estimated time that the power will be restored after an outage
         */
        public EstimatedRestorationTime getEstimatedRestorationTime () { return estimatedRestorationTime; }
        public void setEstimatedRestorationTime ( EstimatedRestorationTime estimatedRestorationTime ) { this.estimatedRestorationTime = estimatedRestorationTime; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EstimatedRestorationTime\"")
        private EstimatedRestorationTime estimatedRestorationTime ;
         
        /**
         * Summary counts of service points (customers) affected by this outage.
         */
        public ServicePointOutageSummary getSummary () { return summary; }
        public void setSummary ( ServicePointOutageSummary summary ) { this.summary = summary; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"summary\"")
        private ServicePointOutageSummary summary ;
         
    }
    /**
     * Transmits an outage plan to a crew in order for the planned outage to be
     * executed.
     */
    @Entity
    @Table(name="\"OutageOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutageOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Free-form comment associated with the outage order
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * The outage plan that is defined to address the outage order.
         */
        public OutagePlan getOutagePlan () { return outagePlan; }
        public void setOutagePlan ( OutagePlan outagePlan ) { this.outagePlan = outagePlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OutagePlan\"")
        private OutagePlan outagePlan ;
         
    }
    /**
     * Document containing the definition of planned outages of equipment and/or
     * usage points. It will reference switching plans that are used to execute
     * the planned outage.
     */
    @Entity
    @Table(name="\"OutagePlan\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class OutagePlan
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The date and time the outage plan was approved
         */
        public String getApprovedDateTime () { return approvedDateTime; }
        public void setApprovedDateTime ( String approvedDateTime ) { this.approvedDateTime = approvedDateTime; }
        @Basic()
        @Column(name="\"approvedDateTime\"")
        private String approvedDateTime ;
         
        /**
         * Date and Time the planned outage was canceled.
         */
        public String getCancelledDateTime () { return cancelledDateTime; }
        public void setCancelledDateTime ( String cancelledDateTime ) { this.cancelledDateTime = cancelledDateTime; }
        @Basic()
        @Column(name="\"cancelledDateTime\"")
        private String cancelledDateTime ;
         
        /**
         * Purpose of this outage plan, such as whether it is to replace equipment
         * or perform maintenance or repairs or to reconfigure network topology.
         */
        public String getPurpose () { return purpose; }
        public void setPurpose ( String purpose ) { this.purpose = purpose; }
        @Basic()
        @Column(name="\"purpose\"")
        private String purpose ;
         
    }
     
    /**
     * This defines if the outage have been predicted or confirmed
     */
    @Entity
    @Table(name="\"OutageStatusKind\"")
    public static class OutageStatusKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * General purpose information for name and other information to contact people.
     */
    @Entity
    @Table(name="\"Person\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Person
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Middle name(s) or initial(s).
         */
        public String getMName () { return mName; }
        public void setMName ( String mName ) { this.mName = mName; }
        @Basic()
        @Column(name="\"mName\"")
        private String mName ;
         
    }
    /**
     */
    @Entity
    @Table(name="\"PlannedOutage\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PlannedOutage extends Outage
    {
        /**
         * a name to denote the community - this could be a name or a code of some
         * kind.
         */
        public String getCommunityDescriptor () { return communityDescriptor; }
        public void setCommunityDescriptor ( String communityDescriptor ) { this.communityDescriptor = communityDescriptor; }
        @Basic()
        @Column(name="\"communityDescriptor\"")
        private String communityDescriptor ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * the total number of customers that are served in the area (both outaged
         * and not outaged).
         */
        public Integer getOriginalCustomersServed () { return originalCustomersServed; }
        public void setOriginalCustomersServed ( Integer originalCustomersServed ) { this.originalCustomersServed = originalCustomersServed; }
        @Basic()
        @Column(name="\"originalCustomersServed\"")
        private Integer originalCustomersServed ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public OutageStatusKind getOutageKind () { return outageKind; }
        public void setOutageKind ( OutageStatusKind outageKind ) { this.outageKind = outageKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"outageKind\"")
        private OutageStatusKind outageKind ;
         
        /**
         * The reason for the planned outage.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Revision number for this document.
         */
        public String getRevisionNumber () { return revisionNumber; }
        public void setRevisionNumber ( String revisionNumber ) { this.revisionNumber = revisionNumber; }
        @Basic()
        @Column(name="\"revisionNumber\"")
        private String revisionNumber ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public CrewStatusKind getStatusKind () { return statusKind; }
        public void setStatusKind ( CrewStatusKind statusKind ) { this.statusKind = statusKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"statusKind\"")
        private CrewStatusKind statusKind ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * This contains an disclaimers the utility would like to place on the data
         * provided to any stakeholder. This may be different for different stakeholders.
         * This should possibly be an attribute under the Organization class but it
         * is placed here for now.
         */
        public String getUtilityDisclaimer () { return utilityDisclaimer; }
        public void setUtilityDisclaimer ( String utilityDisclaimer ) { this.utilityDisclaimer = utilityDisclaimer; }
        @Basic()
        @Column(name="\"utilityDisclaimer\"")
        private String utilityDisclaimer ;
         
        /**
         * Approver of this document.
         */
        public Approver getApprover () { return approver; }
        public void setApprover ( Approver approver ) { this.approver = approver; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Approver\"")
        private Approver approver ;
         
        /**
         * Author of this document.
         */
        public Author getAuthor () { return author; }
        public void setAuthor ( Author author ) { this.author = author; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Author\"")
        private Author author ;
         
        /**
         * The dispatch history associated with the planned outage
         */
        public FieldDispatchHistory getFieldDispatchHistory () { return fieldDispatchHistory; }
        public void setFieldDispatchHistory ( FieldDispatchHistory fieldDispatchHistory ) { this.fieldDispatchHistory = fieldDispatchHistory; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FieldDispatchHistory\"")
        private FieldDispatchHistory fieldDispatchHistory ;
         
        /**
         * Issuer of this document.
         */
        public Issuer getIssuer () { return issuer; }
        public void setIssuer ( Issuer issuer ) { this.issuer = issuer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Issuer\"")
        private Issuer issuer ;
         
        /**
         * Outage plan for executing a planned outage.
         */
        public OutagePlan getOutagePlan () { return outagePlan; }
        public void setOutagePlan ( OutagePlan outagePlan ) { this.outagePlan = outagePlan; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"OutagePlan\"")
        private OutagePlan outagePlan ;
         
    }
    /**
     * Set of spatial coordinates that determine a point, defined in the coordinate
     * system specified in 'Location.CoordinateSystem'. Use a single position
     * point instance to describe a point-oriented location. Use a sequence of
     * position points to describe a line-oriented object (physical location of
     * non-point oriented objects like cables or lines), or area of an object
     * (like a substation or a geographical zone - in this case, have first and
     * last position point with the same values).
     */
    @Entity
    @Table(name="\"PositionPoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PositionPoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Zero-relative sequence number of this point within a series of points.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
        /**
         * X axis position.
         */
        public String getXPosition () { return xPosition; }
        public void setXPosition ( String xPosition ) { this.xPosition = xPosition; }
        @Basic()
        @Column(name="\"xPosition\"")
        private String xPosition ;
         
        /**
         * Y axis position.
         */
        public String getYPosition () { return yPosition; }
        public void setYPosition ( String yPosition ) { this.yPosition = yPosition; }
        @Basic()
        @Column(name="\"yPosition\"")
        private String yPosition ;
         
    }
    /**
     * Document restricting or authorising works on electrical equipment (for
     * example a permit to work, sanction for test, limitation of access, or certificate
     * of isolation), defined based upon organisational practices.
     */
    @Entity
    @Table(name="\"SafetyDocument\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SafetyDocument
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this safety document has been issued.
         */
        public String getIssuedDateTime () { return issuedDateTime; }
        public void setIssuedDateTime ( String issuedDateTime ) { this.issuedDateTime = issuedDateTime; }
        @Basic()
        @Column(name="\"issuedDateTime\"")
        private String issuedDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Date and time this safety document has been released.
         */
        public String getReleasedDateTime () { return releasedDateTime; }
        public void setReleasedDateTime ( String releasedDateTime ) { this.releasedDateTime = releasedDateTime; }
        @Basic()
        @Column(name="\"releasedDateTime\"")
        private String releasedDateTime ;
         
    }
     
    /**
     * Kinds of service requests
     */
    @Entity
    @Table(name="\"ServiceRequestKind\"")
    public static class ServiceRequestKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Date and time for which status 'value' applies.
     */
    public String getDateTime () { return dateTime; }
    public void setDateTime ( String dateTime ) { this.dateTime = dateTime; }
    @Basic()
    @Column(name="\"dateTime\"")
    private String dateTime ;
     
    /**
     * Reason code or explanation for why an object went to the current status
     * 'value'.
     */
    public String getReason () { return reason; }
    public void setReason ( String reason ) { this.reason = reason; }
    @Basic()
    @Column(name="\"reason\"")
    private String reason ;
     
    /**
     * Pertinent information regarding the current 'value', as free form text.
     */
    public String getRemark () { return remark; }
    public void setRemark ( String remark ) { this.remark = remark; }
    @Basic()
    @Column(name="\"remark\"")
    private String remark ;
     
    /**
     * Status value at 'dateTime'; prior status changes may have been kept in
     * instances of activity records associated with the object to which this
     * status applies.
     */
    public String getValue () { return value; }
    public void setValue ( String value ) { this.value = value; }
    @Basic()
    @Column(name="\"value\"")
    private String value ;
     
    /**
     * A generic device designed to close, or open, or both, one or more electric
     * circuits. All switches are two terminal devices including grounding switches.
     * The ACDCTerminal.connected at the two sides of the switch shall not be
     * considered for assessing switch connectivity, i.e. only Switch.open, .normalOpen
     * and .locked are relevant.
     */
    @Entity
    @Table(name="\"Switch\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Switch
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * The maximum continuous current carrying capacity in amps governed by the
         * device material and construction.
         * The attribute shall be a positive value.
         */
        public Double getRatedCurrent () { return ratedCurrent; }
        public void setRatedCurrent ( Double ratedCurrent ) { this.ratedCurrent = ratedCurrent; }
        @Basic()
        @Column(name="\"ratedCurrent\"")
        private Double ratedCurrent ;
         
    }
    /**
     * Atomic switching action.
     */
    @Entity
    @Table(name="\"SwitchingAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Actual date and time of this switching step.
         */
        public String getExecutedDateTime () { return executedDateTime; }
        public void setExecutedDateTime ( String executedDateTime ) { this.executedDateTime = executedDateTime; }
        @Basic()
        @Column(name="\"executedDateTime\"")
        private String executedDateTime ;
         
        /**
         * Date and time when the crew was given the instruction to execute the action;
         * not applicable if the action is performed by operator remote control.
         */
        public String getIssuedDateTime () { return issuedDateTime; }
        public void setIssuedDateTime ( String issuedDateTime ) { this.issuedDateTime = issuedDateTime; }
        @Basic()
        @Column(name="\"issuedDateTime\"")
        private String issuedDateTime ;
         
        /**
         * Switching action to perform.
         */
        public SwitchActionKind getKind () { return kind; }
        public void setKind ( SwitchActionKind kind ) { this.kind = kind; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"kind\"")
        private SwitchActionKind kind ;
         
        /**
         * Phases of the Switching Action
         */
        public PhaseCode getPhases () { return phases; }
        public void setPhases ( PhaseCode phases ) { this.phases = phases; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phases\"")
        private PhaseCode phases ;
         
        /**
         * Planned date and time of this switching step.
         */
        public String getPlannedDateTime () { return plannedDateTime; }
        public void setPlannedDateTime ( String plannedDateTime ) { this.plannedDateTime = plannedDateTime; }
        @Basic()
        @Column(name="\"plannedDateTime\"")
        private String plannedDateTime ;
         
        /**
         * Switch that is the object of this switch action.
         */
        public Switch getOperatedSwitch () { return operatedSwitch; }
        public void setOperatedSwitch ( Switch operatedSwitch ) { this.operatedSwitch = operatedSwitch; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"OperatedSwitch\"")
        private Switch operatedSwitch ;
         
        /**
         * Planned outage for whose scope this switch action applies.
         */
        public Outage getPlannedOutage () { return plannedOutage; }
        public void setPlannedOutage ( Outage plannedOutage ) { this.plannedOutage = plannedOutage; }
        @ManyToOne(fetch=FetchType.LAZY, optional=true)
        @JoinColumn(name="\"PlannedOutage\"")
        private Outage plannedOutage ;
         
    }
    /**
     * Event indicating the completion (success or fail) of any switching action
     * (jumper action, cut action, tag action, etc). The switching action may
     * or may not be a consequential event in response to a request to complete
     * the action.
     */
    @Entity
    @Table(name="\"SwitchingEvent\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchingEvent
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time this activity record has been created (different from the
         * 'status.dateTime', which is the time of a status change of the associated
         * object, if applicable).
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Reason for event resulting in this activity record, typically supplied
         * when user initiated.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Severity level of event resulting in this activity record.
         */
        public String getSeverity () { return severity; }
        public void setSeverity ( String severity ) { this.severity = severity; }
        @Basic()
        @Column(name="\"severity\"")
        private String severity ;
         
        /**
         * Type of event resulting in this activity record.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * Trouble order sends an incident to a crew to initiate a response to an
     * unplanned outage.
     */
    @Entity
    @Table(name="\"TroubleOrder\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleOrder
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free-form comment associated with the trouble order.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Electronic address.
         */
        public ElectronicAddress getElectronicAddress () { return electronicAddress; }
        public void setElectronicAddress ( ElectronicAddress electronicAddress ) { this.electronicAddress = electronicAddress; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"electronicAddress\"")
        private ElectronicAddress electronicAddress ;
         
    }
     
    /**
     * Kind of trouble reporting.
     */
    @Entity
    @Table(name="\"TroubleReportingKind\"")
    public static class TroubleReportingKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     */
    @Entity
    @Table(name="\"TroubleTicket\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TroubleTicket
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free-form comment associated with the trouble call for example, "customer
         * reported a large flash", etc.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * Date and time the trouble has been reported.
         */
        public String getDateTimeOfReport () { return dateTimeOfReport; }
        public void setDateTimeOfReport ( String dateTimeOfReport ) { this.dateTimeOfReport = dateTimeOfReport; }
        @Basic()
        @Column(name="\"dateTimeOfReport\"")
        private String dateTimeOfReport ;
         
        /**
         * Indicates whether the first responder such as police, fire department etc.has
         * been notified and whether they are on site or en route.
         */
        public String getFirstResponderStatus () { return firstResponderStatus; }
        public void setFirstResponderStatus ( String firstResponderStatus ) { this.firstResponderStatus = firstResponderStatus; }
        @Basic()
        @Column(name="\"firstResponderStatus\"")
        private String firstResponderStatus ;
         
        /**
         * Set to true if the outage report indicated that other neighbors are also
         * out of power.
         */
        public Boolean getMultiplePremises () { return multiplePremises; }
        public void setMultiplePremises ( Boolean multiplePremises ) { this.multiplePremises = multiplePremises; }
        @Basic()
        @Column(name="\"multiplePremises\"")
        private Boolean multiplePremises ;
         
        /**
         * Indicates how the customer reported trouble.
         */
        public String getReportingKind () { return reportingKind; }
        public void setReportingKind ( String reportingKind ) { this.reportingKind = reportingKind; }
        @Basic()
        @Column(name="\"reportingKind\"")
        private String reportingKind ;
         
        /**
         * Date and time this trouble ticket has been resolved.
         */
        public String getResolvedDateTime () { return resolvedDateTime; }
        public void setResolvedDateTime ( String resolvedDateTime ) { this.resolvedDateTime = resolvedDateTime; }
        @Basic()
        @Column(name="\"resolvedDateTime\"")
        private String resolvedDateTime ;
         
        /**
         * Trouble code (e.g., power down, flickering lights, partial power, etc).
         */
        public String getTroubleCode () { return troubleCode; }
        public void setTroubleCode ( String troubleCode ) { this.troubleCode = troubleCode; }
        @Basic()
        @Column(name="\"troubleCode\"")
        private String troubleCode ;
         
        /**
         * Incident reported in this trouble ticket
         */
        public Incident getIncident () { return incident; }
        public void setIncident ( Incident incident ) { this.incident = incident; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Incident\"")
        private Incident incident ;
         
        /**
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * Document describing the consequence of an unplanned outage in a part of
     * the electrical network. For the purposes of this model, an unplanned outage
     * refers to a state where energy is not delivered; such as, customers out
     * of service, a street light is not served, etc.
     * A unplanned outage may be created upon:
     * - impacts the SAIDI calculation
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     */
    @Entity
    @Table(name="\"UnplannedOutage\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class UnplannedOutage extends Outage
    {
        /**
         * The cause of this outage. This is the cause that is used to present to
         * external entities. That is, the cause is weather, equipment failure, etc.
         * Note: At present, this is a free string text; it could be replaced with
         * an enumeration in the future.
         */
        public String getCause () { return cause; }
        public void setCause ( String cause ) { this.cause = cause; }
        @Basic()
        @Column(name="\"cause\"")
        private String cause ;
         
        /**
         * The possible cause that could be associated with this unplanned outage.
         */
        public OutageCauseKind getCauseKind () { return causeKind; }
        public void setCauseKind ( OutageCauseKind causeKind ) { this.causeKind = causeKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"causeKind\"")
        private OutageCauseKind causeKind ;
         
        /**
         * a name to denote the community - this could be a name or a code of some
         * kind.
         */
        public String getCommunityDescriptor () { return communityDescriptor; }
        public void setCommunityDescriptor ( String communityDescriptor ) { this.communityDescriptor = communityDescriptor; }
        @Basic()
        @Column(name="\"communityDescriptor\"")
        private String communityDescriptor ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * number of customers that have been restored in the area.
         */
        public Integer getCustomersRestored () { return customersRestored; }
        public void setCustomersRestored ( Integer customersRestored ) { this.customersRestored = customersRestored; }
        @Basic()
        @Column(name="\"customersRestored\"")
        private Integer customersRestored ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The updated number of meters affected by the outage as reported by the
         * OMS within the utility. It is assumed this number will be updated repeatedly
         * until the full outage is resolved.
         */
        public Integer getMetersAffected () { return metersAffected; }
        public void setMetersAffected ( Integer metersAffected ) { this.metersAffected = metersAffected; }
        @Basic()
        @Column(name="\"metersAffected\"")
        private Integer metersAffected ;
         
        /**
         * the total number of customers that are served in the area (both outaged
         * and not outaged).
         */
        public Integer getOriginalCustomersServed () { return originalCustomersServed; }
        public void setOriginalCustomersServed ( Integer originalCustomersServed ) { this.originalCustomersServed = originalCustomersServed; }
        @Basic()
        @Column(name="\"originalCustomersServed\"")
        private Integer originalCustomersServed ;
         
        /**
         * The original number of meters that were affected as reported by the OMS
         * within the utility. That is, this is the total number of meters that were
         * out at the beginning of the outage.
         */
        public Integer getOriginalMetersAffected () { return originalMetersAffected; }
        public void setOriginalMetersAffected ( Integer originalMetersAffected ) { this.originalMetersAffected = originalMetersAffected; }
        @Basic()
        @Column(name="\"originalMetersAffected\"")
        private Integer originalMetersAffected ;
         
        /**
         * Defines if the outage has been verified or is only estimated
         */
        public OutageStatusKind getOutageKind () { return outageKind; }
        public void setOutageKind ( OutageStatusKind outageKind ) { this.outageKind = outageKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"outageKind\"")
        private OutageStatusKind outageKind ;
         
        /**
         * The earliest start time of the Outage - as reported by some system or individual
         */
        public String getReportedStartTime () { return reportedStartTime; }
        public void setReportedStartTime ( String reportedStartTime ) { this.reportedStartTime = reportedStartTime; }
        @Basic()
        @Column(name="\"reportedStartTime\"")
        private String reportedStartTime ;
         
        /**
         * defines the status of the crew as in dispatched or arrived, etc.
         */
        public CrewStatusKind getStatusKind () { return statusKind; }
        public void setStatusKind ( CrewStatusKind statusKind ) { this.statusKind = statusKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"statusKind\"")
        private CrewStatusKind statusKind ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * This contains an disclaimers the utility would like to place on the data
         * provided to any stakeholder. This may be different for different stakeholders.
         * This should possibly be an attribute under the Organization class but it
         * is placed here for now.
         */
        public String getUtilityDisclaimer () { return utilityDisclaimer; }
        public void setUtilityDisclaimer ( String utilityDisclaimer ) { this.utilityDisclaimer = utilityDisclaimer; }
        @Basic()
        @Column(name="\"utilityDisclaimer\"")
        private String utilityDisclaimer ;
         
        /**
         * Actual outage period; end of the period corresponds to the actual restoration
         * time.
         */
        public DateTimeInterval getActualPeriod () { return actualPeriod; }
        public void setActualPeriod ( DateTimeInterval actualPeriod ) { this.actualPeriod = actualPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"actualPeriod\"")
        private DateTimeInterval actualPeriod ;
         
        /**
         * Estimated outage period for a planned outage. The start of the period is
         * the start of the planned outage and the end of the period corresponds to
         * the end of the planned outage.
         */
        public DateTimeInterval getEstimatedPeriod () { return estimatedPeriod; }
        public void setEstimatedPeriod ( DateTimeInterval estimatedPeriod ) { this.estimatedPeriod = estimatedPeriod; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"estimatedPeriod\"")
        private DateTimeInterval estimatedPeriod ;
         
        /**
         * The estimated time that the power will be restored after an outage
         */
        public EstimatedRestorationTime getEstimatedRestorationTime () { return estimatedRestorationTime; }
        public void setEstimatedRestorationTime ( EstimatedRestorationTime estimatedRestorationTime ) { this.estimatedRestorationTime = estimatedRestorationTime; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EstimatedRestorationTime\"")
        private EstimatedRestorationTime estimatedRestorationTime ;
         
        /**
         * The dispatch history associated with the unplanned outage
         */
        public FieldDispatchHistory getFieldDispatchHistory () { return fieldDispatchHistory; }
        public void setFieldDispatchHistory ( FieldDispatchHistory fieldDispatchHistory ) { this.fieldDispatchHistory = fieldDispatchHistory; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FieldDispatchHistory\"")
        private FieldDispatchHistory fieldDispatchHistory ;
         
        /**
         * Summary counts of service points (customers) affected by this outage.
         */
        public ServicePointOutageSummary getSummary () { return summary; }
        public void setSummary ( ServicePointOutageSummary summary ) { this.summary = summary; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"summary\"")
        private ServicePointOutageSummary summary ;
         
    }
    /**
     * Records information about the status of work or work task at a point in
     * time.
     */
    @Entity
    @Table(name="\"WorkActivityRecord\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WorkActivityRecord
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Estimated percentage of completion of this individual work task or overall
         * work order.
         */
        public Double getPercentComplete () { return percentComplete; }
        public void setPercentComplete ( Double percentComplete ) { this.percentComplete = percentComplete; }
        @Basic()
        @Column(name="\"percentComplete\"")
        private Double percentComplete ;
         
    }
    /**
     * Asset used to perform work.
     */
    @Entity
    @Table(name="\"WorkAsset\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WorkAsset
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * Information about a particular location for various forms of work.
     */
    @Entity
    @Table(name="\"WorkLocation\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class WorkLocation extends Location
    {
        /**
         * (if applicable) Direction that allows field crews to quickly find a given
         * asset. For a given location, such as a street address, this is the relative
         * direction in which to find the asset. For example, a streetlight may be
         * located at the 'NW' (northwest) corner of the customer's site, or a usage
         * point may be located on the second floor of an apartment building.
         */
        public String getDirection () { return direction; }
        public void setDirection ( String direction ) { this.direction = direction; }
        @Basic()
        @Column(name="\"direction\"")
        private String direction ;
         
        /**
         * (if applicable) Reference to geographical information source, often external
         * to the utility.
         */
        public String getGeoInfoReference () { return geoInfoReference; }
        public void setGeoInfoReference ( String geoInfoReference ) { this.geoInfoReference = geoInfoReference; }
        @Basic()
        @Column(name="\"geoInfoReference\"")
        private String geoInfoReference ;
         
        /**
         * Classification by utility's corporate standards and practices, relative
         * to the location itself (e.g., geographical, functional accounting, etc.,
         * not a given property that happens to exist at that location).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Coordinate system used to describe position points of this location.
         */
        public CoordinateSystem getCoordinateSystem () { return coordinateSystem; }
        public void setCoordinateSystem ( CoordinateSystem coordinateSystem ) { this.coordinateSystem = coordinateSystem; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CoordinateSystem\"")
        private CoordinateSystem coordinateSystem ;
         
    }
     
    /**
     * Kind of status, specific to work.
     */
    @Entity
    @Table(name="\"WorkStatusKind\"")
    public static class WorkStatusKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A task within a set of work.
     */
    @Entity
    @Table(name="\"WorkTask\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WorkTask
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time work task was completed.
         */
        public String getCompletedDateTime () { return completedDateTime; }
        public void setCompletedDateTime ( String completedDateTime ) { this.completedDateTime = completedDateTime; }
        @Basic()
        @Column(name="\"completedDateTime\"")
        private String completedDateTime ;
         
        /**
         * Total contractor costs associated with the work task.
         */
        public String getContractorCost () { return contractorCost; }
        public void setContractorCost ( String contractorCost ) { this.contractorCost = contractorCost; }
        @Basic()
        @Column(name="\"contractorCost\"")
        private String contractorCost ;
         
        /**
         * Estimated time of arrival, so that customer or police/fire department can
         * be informed when the crew will arrive.
         */
        public String getCrewETA () { return crewETA; }
        public void setCrewETA ( String crewETA ) { this.crewETA = crewETA; }
        @Basic()
        @Column(name="\"crewETA\"")
        private String crewETA ;
         
        /**
         * Time and Date when the work task will be completed.
         */
        public String getEstimatedCompletionTime () { return estimatedCompletionTime; }
        public void setEstimatedCompletionTime ( String estimatedCompletionTime ) { this.estimatedCompletionTime = estimatedCompletionTime; }
        @Basic()
        @Column(name="\"estimatedCompletionTime\"")
        private String estimatedCompletionTime ;
         
        /**
         * Instructions for performing this task.
         */
        public String getInstruction () { return instruction; }
        public void setInstruction ( String instruction ) { this.instruction = instruction; }
        @Basic()
        @Column(name="\"instruction\"")
        private String instruction ;
         
        /**
         * Kind of work.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Total labor costs associated with the work task.
         */
        public String getLaborCost () { return laborCost; }
        public void setLaborCost ( String laborCost ) { this.laborCost = laborCost; }
        @Basic()
        @Column(name="\"laborCost\"")
        private String laborCost ;
         
        /**
         * Hours of labor expended under work task.
         */
        public Double getLaborHours () { return laborHours; }
        public void setLaborHours ( Double laborHours ) { this.laborHours = laborHours; }
        @Basic()
        @Column(name="\"laborHours\"")
        private Double laborHours ;
         
        /**
         * Total material costs associated with the work task.
         */
        public String getMateriallCost () { return materiallCost; }
        public void setMateriallCost ( String materiallCost ) { this.materiallCost = materiallCost; }
        @Basic()
        @Column(name="\"materiallCost\"")
        private String materiallCost ;
         
        /**
         * If specified, override schedule and perform this task in accordance with
         * instructions specified here.
         */
        public String getSchedOverride () { return schedOverride; }
        public void setSchedOverride ( String schedOverride ) { this.schedOverride = schedOverride; }
        @Basic()
        @Column(name="\"schedOverride\"")
        private String schedOverride ;
         
        /**
         * Date and time work task was started.
         */
        public String getStartedDateTime () { return startedDateTime; }
        public void setStartedDateTime ( String startedDateTime ) { this.startedDateTime = startedDateTime; }
        @Basic()
        @Column(name="\"startedDateTime\"")
        private String startedDateTime ;
         
        /**
         * Kind of work status.
         */
        public String getStatusKind () { return statusKind; }
        public void setStatusKind ( String statusKind ) { this.statusKind = statusKind; }
        @Basic()
        @Column(name="\"statusKind\"")
        private String statusKind ;
         
        /**
         * Kind of work.
         */
        public String getTaskKind () { return taskKind; }
        public void setTaskKind ( String taskKind ) { this.taskKind = taskKind; }
        @Basic()
        @Column(name="\"taskKind\"")
        private String taskKind ;
         
        /**
         * Total tool costs associated with the work task.
         */
        public String getToolCost () { return toolCost; }
        public void setToolCost ( String toolCost ) { this.toolCost = toolCost; }
        @Basic()
        @Column(name="\"toolCost\"")
        private String toolCost ;
         
        /**
         * Location for this work/task.
         */
        public WorkLocation getWorkLocation () { return workLocation; }
        public void setWorkLocation ( WorkLocation workLocation ) { this.workLocation = workLocation; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WorkLocation\"")
        private WorkLocation workLocation ;
         
    }
     
    /**
     * Kinds of work tasks.
     */
    @Entity
    @Table(name="\"WorkTaskKind\"")
    public static class WorkTaskKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    public static final Class[] allClasses = new Class[]
    {
        CoordinateSystem.class,
        Crew.class,
        CrewMember.class,
        CrewStatusKind.class,
        CrewType.class,
        DesignLocation.class,
        Incident.class,
        Location.class,
        Outage.class,
        OutageOrder.class,
        OutagePlan.class,
        OutageStatusKind.class,
        Person.class,
        PlannedOutage.class,
        PositionPoint.class,
        SafetyDocument.class,
        ServiceRequestKind.class,
        Switch.class,
        SwitchingAction.class,
        SwitchingEvent.class,
        TroubleOrder.class,
        TroubleReportingKind.class,
        TroubleTicket.class,
        UnplannedOutage.class,
        WorkActivityRecord.class,
        WorkAsset.class,
        WorkLocation.class,
        WorkStatusKind.class,
        WorkTask.class,
        WorkTaskKind.class
    };
}
