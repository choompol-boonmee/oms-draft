package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for DTMS_OMS_Profile
 * Generated by CIMTool http://cimtool.org
 */
public class DTMS_OMS_Profile
{
    /**
     * Records activity for an entity at a point in time; activity may be for
     * an event that has already occurred or for a planned activity.
     */
    @Entity
    @Table(name="\"ActivityRecord\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ActivityRecord
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time this activity record has been created (different from the
         * 'status.dateTime', which is the time of a status change of the associated
         * object, if applicable).
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Reason for event resulting in this activity record, typically supplied
         * when user initiated.
         */
        public String getReason () { return reason; }
        public void setReason ( String reason ) { this.reason = reason; }
        @Basic()
        @Column(name="\"reason\"")
        private String reason ;
         
        /**
         * Severity level of event resulting in this activity record.
         */
        public String getSeverity () { return severity; }
        public void setSeverity ( String severity ) { this.severity = severity; }
        @Basic()
        @Column(name="\"severity\"")
        private String severity ;
         
        /**
         * Type of event resulting in this activity record.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * An algorithm or calculation for making an assessment about an asset or
     * asset grouping for lifecycle decision making.
     */
    @Entity
    @Table(name="\"Analytic\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Analytic
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Value that indicates best possible numeric value.
         */
        public Double getBestValue () { return bestValue; }
        public void setBestValue ( Double bestValue ) { this.bestValue = bestValue; }
        @Basic()
        @Column(name="\"bestValue\"")
        private Double bestValue ;
         
        /**
         * Date and time that this document was created.
         */
        public String getCreatedDateTime () { return createdDateTime; }
        public void setCreatedDateTime ( String createdDateTime ) { this.createdDateTime = createdDateTime; }
        @Basic()
        @Column(name="\"createdDateTime\"")
        private String createdDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Kind of analytic this analytic is.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Date and time this document was last modified. Documents may potentially
         * be modified many times during their lifetime.
         */
        public String getLastModifiedDateTime () { return lastModifiedDateTime; }
        public void setLastModifiedDateTime ( String lastModifiedDateTime ) { this.lastModifiedDateTime = lastModifiedDateTime; }
        @Basic()
        @Column(name="\"lastModifiedDateTime\"")
        private String lastModifiedDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * The scoring scale kind.
         */
        public String getScaleKind () { return scaleKind; }
        public void setScaleKind ( String scaleKind ) { this.scaleKind = scaleKind; }
        @Basic()
        @Column(name="\"scaleKind\"")
        private String scaleKind ;
         
        /**
         * Value that indicates worst possible numeric value.
         */
        public Double getWorstValue () { return worstValue; }
        public void setWorstValue ( Double worstValue ) { this.worstValue = worstValue; }
        @Basic()
        @Column(name="\"worstValue\"")
        private Double worstValue ;
         
    }
     
    /**
     * Possible kinds of analytics.
     */
    @Entity
    @Table(name="\"AnalyticKind\"")
    public static class AnalyticKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * An indicative scoring by an analytic that can be used to characterize the
     * health of or the risk associated with one or more assets. The analytic
     * score reflects the results of an execution of an analytic against an asset
     * or group of assets.
     */
    @Entity
    @Table(name="\"AnalyticScore\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AnalyticScore
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Timestamp of when the score was calculated.
         */
        public String getCalculationDateTime () { return calculationDateTime; }
        public void setCalculationDateTime ( String calculationDateTime ) { this.calculationDateTime = calculationDateTime; }
        @Basic()
        @Column(name="\"calculationDateTime\"")
        private String calculationDateTime ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Date-time for when the score applies.
         */
        public String getEffectiveDateTime () { return effectiveDateTime; }
        public void setEffectiveDateTime ( String effectiveDateTime ) { this.effectiveDateTime = effectiveDateTime; }
        @Basic()
        @Column(name="\"effectiveDateTime\"")
        private String effectiveDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Asset health score value.
         */
        public Double getValue () { return value; }
        public void setValue ( Double value ) { this.value = value; }
        @Basic()
        @Column(name="\"value\"")
        private Double value ;
         
    }
    /**
     * Tangible resource of the utility, including power system equipment, various
     * end devices, cabinets, buildings, etc. For electrical network equipment,
     * the role of the asset is defined through PowerSystemResource and its subclasses,
     * defined mainly in the Wires model (refer to IEC61970-301 and model package
     * IEC61970::Wires). Asset description places emphasis on the physical characteristics
     * of the equipment fulfilling that role.
     */
    @Entity
    @Table(name="\"Asset\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Asset
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Condition of asset at last baseline. Examples include new, rebuilt, overhaul
         * required, other. Refer to inspection data for information on the most current
         * condition of the asset.
         */
        public String getInitialCondition () { return initialCondition; }
        public void setInitialCondition ( String initialCondition ) { this.initialCondition = initialCondition; }
        @Basic()
        @Column(name="\"initialCondition\"")
        private String initialCondition ;
         
        /**
         * Percentage of initial life expectancy that has been lost as of the last
         * life expectancy baseline. Represents
         * (initial life expectancy - current life expectancy) / initial life expectancy.
         */
        public Double getInitialLossOfLife () { return initialLossOfLife; }
        public void setInitialLossOfLife ( Double initialLossOfLife ) { this.initialLossOfLife = initialLossOfLife; }
        @Basic()
        @Column(name="\"initialLossOfLife\"")
        private Double initialLossOfLife ;
         
        /**
         * Indication of whether asset is currently deployed (in use), ready to be
         * put into use or not available for use.
         */
        public String getInUseState () { return inUseState; }
        public void setInUseState ( String inUseState ) { this.inUseState = inUseState; }
        @Basic()
        @Column(name="\"inUseState\"")
        private String inUseState ;
         
        /**
         * Kind of asset. Used in description of asset components in asset instance
         * templates.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Current lifecycle state of asset.
         */
        public String getLifecycleState () { return lifecycleState; }
        public void setLifecycleState ( String lifecycleState ) { this.lifecycleState = lifecycleState; }
        @Basic()
        @Column(name="\"lifecycleState\"")
        private String lifecycleState ;
         
        /**
         * Lot number for this asset. Even for the same model and version number,
         * many assets are manufactured in lots.
         */
        public String getLotNumber () { return lotNumber; }
        public void setLotNumber ( String lotNumber ) { this.lotNumber = lotNumber; }
        @Basic()
        @Column(name="\"lotNumber\"")
        private String lotNumber ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Purchase price of asset.
         */
        public String getPurchasePrice () { return purchasePrice; }
        public void setPurchasePrice ( String purchasePrice ) { this.purchasePrice = purchasePrice; }
        @Basic()
        @Column(name="\"purchasePrice\"")
        private String purchasePrice ;
         
        /**
         * Reason asset retired.
         */
        public String getRetiredReason () { return retiredReason; }
        public void setRetiredReason ( String retiredReason ) { this.retiredReason = retiredReason; }
        @Basic()
        @Column(name="\"retiredReason\"")
        private String retiredReason ;
         
        /**
         * Serial number of this asset.
         */
        public String getSerialNumber () { return serialNumber; }
        public void setSerialNumber ( String serialNumber ) { this.serialNumber = serialNumber; }
        @Basic()
        @Column(name="\"serialNumber\"")
        private String serialNumber ;
         
        /**
         * Utility-specific classification of Asset and its subtypes, according to
         * their corporate standards, practices, and existing IT systems (e.g., for
         * management of assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Container of this asset.
         */
        public AssetContainer getAssetContainer () { return assetContainer; }
        public void setAssetContainer ( AssetContainer assetContainer ) { this.assetContainer = assetContainer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AssetContainer\"")
        private AssetContainer assetContainer ;
         
        /**
         * This asset's deployment.
         */
        public AssetDeployment getAssetDeployment () { return assetDeployment; }
        public void setAssetDeployment ( AssetDeployment assetDeployment ) { this.assetDeployment = assetDeployment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AssetDeployment\"")
        private AssetDeployment assetDeployment ;
         
        /**
         * Data applicable to this asset.
         */
        public AssetInfo getAssetInfo () { return assetInfo; }
        public void setAssetInfo ( AssetInfo assetInfo ) { this.assetInfo = assetInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AssetInfo\"")
        private AssetInfo assetInfo ;
         
    }
    /**
     * Asset that is aggregation of other assets such as conductors, transformers,
     * switchgear, land, fences, buildings, equipment, vehicles, etc.
     */
    @Entity
    @Table(name="\"AssetContainer\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class AssetContainer extends Asset
    {
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * Deployment of asset deployment in a power system resource role.
     */
    @Entity
    @Table(name="\"AssetDeployment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AssetDeployment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Current deployment state of asset.
         */
        public String getDeploymentState () { return deploymentState; }
        public void setDeploymentState ( String deploymentState ) { this.deploymentState = deploymentState; }
        @Basic()
        @Column(name="\"deploymentState\"")
        private String deploymentState ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Kind of facility (like substation or pole or building or plant or service
         * center) at which asset deployed.
         */
        public String getFacilityKind () { return facilityKind; }
        public void setFacilityKind ( String facilityKind ) { this.facilityKind = facilityKind; }
        @Basic()
        @Column(name="\"facilityKind\"")
        private String facilityKind ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Type of network role transformer is playing in this deployment (applies
         * to transformer assets only).
         */
        public String getTransformerApplication () { return transformerApplication; }
        public void setTransformerApplication ( String transformerApplication ) { this.transformerApplication = transformerApplication; }
        @Basic()
        @Column(name="\"transformerApplication\"")
        private String transformerApplication ;
         
    }
    /**
     * Set of attributes of an asset, representing typical datasheet information
     * of a physical device that can be instantiated and shared in different data
     * exchange contexts:
     * - as attributes of an asset instance (installed or in stock)
     * - as attributes of an asset model (product by a manufacturer)
     * - as attributes of a type asset (generic type of an asset as used in designs/extension
     * planning).
     */
    @Entity
    @Table(name="\"AssetInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AssetInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
     
    /**
     * Kinds of assets or asset components.
     */
    @Entity
    @Table(name="\"AssetKind\"")
    public static class AssetKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Lifecycle states an asset can be in.
     * While the possible lifecycle states are standardized, the allowed transitions
     * are not - they are intended to be defined by the business process requirements
     * of local implementations.
     */
    @Entity
    @Table(name="\"AssetLifecycleStateKind\"")
    public static class AssetLifecycleStateKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * a Assets that may be used for planning, work or design purposes.
     */
    @Entity
    @Table(name="\"CatalogAssetType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CatalogAssetType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Estimated unit cost (or cost per unit length) of this type of asset. It
         * does not include labor to install, construct or configure it.
         */
        public String getEstimatedUnitCost () { return estimatedUnitCost; }
        public void setEstimatedUnitCost ( String estimatedUnitCost ) { this.estimatedUnitCost = estimatedUnitCost; }
        @Basic()
        @Column(name="\"estimatedUnitCost\"")
        private String estimatedUnitCost ;
         
        /**
         * Kind of asset (from enumerated list).
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * True if item is a stock item (default).
         */
        public Boolean getStockItem () { return stockItem; }
        public void setStockItem ( Boolean stockItem ) { this.stockItem = stockItem; }
        @Basic()
        @Column(name="\"stockItem\"")
        private Boolean stockItem ;
         
        /**
         * Description of type of asset.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * Coordinate reference system.
     */
    @Entity
    @Table(name="\"CoordinateSystem\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CoordinateSystem
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A Uniform Resource Name (URN) for the coordinate reference system (crs)
         * used to define 'Location.PositionPoints'.
         * An example would be the European Petroleum Survey Group (EPSG) code for
         * a coordinate reference system, defined in URN under the Open Geospatial
         * Consortium (OGC) namespace as: urn:ogc:def:crs:EPSG::XXXX, where XXXX is
         * an EPSG code (a full list of codes can be found at the EPSG Registry web
         * site http://www.epsg-registry.org/). To define the coordinate system as
         * being WGS84 (latitude, longitude) using an EPSG OGC, this attribute would
         * be urn:ogc:def:crs:EPSG::4.3.2.6
         * A profile should limit this code to a set of allowed URNs agreed to by
         * all sending and receiving parties.
         */
        public String getCrsUrn () { return crsUrn; }
        public void setCrsUrn ( String crsUrn ) { this.crsUrn = crsUrn; }
        @Basic()
        @Column(name="\"crsUrn\"")
        private String crsUrn ;
         
    }
     
    /**
     * Kind of corporate standard.
     */
    @Entity
    @Table(name="\"CorporateStandardKind\"")
    public static class CorporateStandardKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Possible states of asset deployment.
     */
    @Entity
    @Table(name="\"DeploymentStateKind\"")
    public static class DeploymentStateKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Types of facilities at which an asset can be deployed.
     */
    @Entity
    @Table(name="\"FacilityKind\"")
    public static class FacilityKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Possible 'in use' states that an asset can be in.
     */
    @Entity
    @Table(name="\"InUseStateKind\"")
    public static class InUseStateKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * The place, scene, or point of something where someone or something has
     * been, is, and/or will be at a given moment in time. It can be defined with
     * one or more position points (coordinates) in a given coordinate system.
     */
    @Entity
    @Table(name="\"Location\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Location
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * (if applicable) Direction that allows field crews to quickly find a given
         * asset. For a given location, such as a street address, this is the relative
         * direction in which to find the asset. For example, a streetlight may be
         * located at the 'NW' (northwest) corner of the customer's site, or a usage
         * point may be located on the second floor of an apartment building.
         */
        public String getDirection () { return direction; }
        public void setDirection ( String direction ) { this.direction = direction; }
        @Basic()
        @Column(name="\"direction\"")
        private String direction ;
         
        /**
         * (if applicable) Reference to geographical information source, often external
         * to the utility.
         */
        public String getGeoInfoReference () { return geoInfoReference; }
        public void setGeoInfoReference ( String geoInfoReference ) { this.geoInfoReference = geoInfoReference; }
        @Basic()
        @Column(name="\"geoInfoReference\"")
        private String geoInfoReference ;
         
        /**
         * Classification by utility's corporate standards and practices, relative
         * to the location itself (e.g., geographical, functional accounting, etc.,
         * not a given property that happens to exist at that location).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Coordinate system used to describe position points of this location.
         */
        public CoordinateSystem getCoordinateSystem () { return coordinateSystem; }
        public void setCoordinateSystem ( CoordinateSystem coordinateSystem ) { this.coordinateSystem = coordinateSystem; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CoordinateSystem\"")
        private CoordinateSystem coordinateSystem ;
         
    }
    /**
     * A Measurement represents any measured, calculated or non-measured non-calculated
     * quantity. Any piece of equipment may contain Measurements, e.g. a substation
     * may have temperature measurements and door open indications, a transformer
     * may have oil temperature and tank pressure measurements, a bay may contain
     * a number of power flow measurements and a Breaker may contain a switch
     * status measurement.
     * The PSR - Measurement association is intended to capture this use of Measurement
     * and is included in the naming hierarchy based on EquipmentContainer. The
     * naming hierarchy typically has Measurements as leaves, e.g. Substation-VoltageLevel-Bay-Switch-Measurement.
     * Some Measurements represent quantities related to a particular sensor location
     * in the network, e.g. a voltage transformer (VT) or potential transformer
     * (PT) at a busbar or a current transformer (CT) at the bar between a breaker
     * and an isolator. The sensing position is not captured in the PSR - Measurement
     * association. Instead it is captured by the Measurement - Terminal association
     * that is used to define the sensing location in the network topology. The
     * location is defined by the connection of the Terminal to ConductingEquipment.
     * If both a Terminal and PSR are associated, and the PSR is of type ConductingEquipment,
     * the associated Terminal should belong to that ConductingEquipment instance.
     * When the sensor location is needed both Measurement-PSR and Measurement-Terminal
     * are used. The Measurement-Terminal association is never used alone.
     */
    @Entity
    @Table(name="\"Measurement\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Measurement
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Specifies the type of measurement. For example, this specifies if the measurement
         * represents an indoor temperature, outdoor temperature, bus voltage, line
         * flow, etc.
         * When the measurementType is set to "Specialization", the type of Measurement
         * is defined in more detail by the specialized class which inherits from
         * Measurement.
         */
        public String getMeasurementType () { return measurementType; }
        public void setMeasurementType ( String measurementType ) { this.measurementType = measurementType; }
        @Basic()
        @Column(name="\"measurementType\"")
        private String measurementType ;
         
        /**
         * Indicates to which phases the measurement applies and avoids the need to
         * use 'measurementType' to also encode phase information (which would explode
         * the types). The phase information in Measurement, along with 'measurementType'
         * and 'phases' uniquely defines a Measurement for a device, based on normal
         * network phase. Their meaning will not change when the computed energizing
         * phasing is changed due to jumpers or other reasons.
         * If the attribute is missing three phases (ABC) shall be assumed.
         */
        public PhaseCode getPhases () { return phases; }
        public void setPhases ( PhaseCode phases ) { this.phases = phases; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"phases\"")
        private PhaseCode phases ;
         
        /**
         * The unit multiplier of the measured quantity.
         */
        public String getUnitMultiplier () { return unitMultiplier; }
        public void setUnitMultiplier ( String unitMultiplier ) { this.unitMultiplier = unitMultiplier; }
        @Basic()
        @Column(name="\"unitMultiplier\"")
        private String unitMultiplier ;
         
        /**
         * The unit of measure of the measured quantity.
         */
        public String getUnitSymbol () { return unitSymbol; }
        public void setUnitSymbol ( String unitSymbol ) { this.unitSymbol = unitSymbol; }
        @Basic()
        @Column(name="\"unitSymbol\"")
        private String unitSymbol ;
         
        /**
         * The measurement action that is performed on the measurement
         */
        public MeasurementAction getMeasurementAction () { return measurementAction; }
        public void setMeasurementAction ( MeasurementAction measurementAction ) { this.measurementAction = measurementAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"MeasurementAction\"")
        private MeasurementAction measurementAction ;
         
    }
    /**
     * Measurement taken as a switching step.
     */
    @Entity
    @Table(name="\"MeasurementAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MeasurementAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Actual date and time of this switching step.
         */
        public String getExecutedDateTime () { return executedDateTime; }
        public void setExecutedDateTime ( String executedDateTime ) { this.executedDateTime = executedDateTime; }
        @Basic()
        @Column(name="\"executedDateTime\"")
        private String executedDateTime ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Planned date and time of this switching step.
         */
        public String getPlannedDateTime () { return plannedDateTime; }
        public void setPlannedDateTime ( String plannedDateTime ) { this.plannedDateTime = plannedDateTime; }
        @Basic()
        @Column(name="\"plannedDateTime\"")
        private String plannedDateTime ;
         
    }
    /**
     * The current state for a measurement. A state value is an instance of a
     * measurement from a specific source. Measurements can be associated with
     * many state values, each representing a different source for the measurement.
     */
    @Entity
    @Table(name="\"MeasurementValue\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MeasurementValue
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The limit, expressed as a percentage of the sensor maximum, that errors
         * will not exceed when the sensor is used under reference conditions.
         */
        public Double getSensorAccuracy () { return sensorAccuracy; }
        public void setSensorAccuracy ( Double sensorAccuracy ) { this.sensorAccuracy = sensorAccuracy; }
        @Basic()
        @Column(name="\"sensorAccuracy\"")
        private Double sensorAccuracy ;
         
        /**
         * The time when the value was last updated.
         */
        public String getTimeStamp () { return timeStamp; }
        public void setTimeStamp ( String timeStamp ) { this.timeStamp = timeStamp; }
        @Basic()
        @Column(name="\"timeStamp\"")
        private String timeStamp ;
         
        /**
         * The value to supervise.
         */
        public Double getValue () { return value; }
        public void setValue ( Double value ) { this.value = value; }
        @Basic(optional=true)
        @Column(name="\"value\"")
        private Double value ;
         
        /**
         * Link to the physical telemetered point associated with this measurement.
         */
        public RemoteSource getRemoteSource () { return remoteSource; }
        public void setRemoteSource ( RemoteSource remoteSource ) { this.remoteSource = remoteSource; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RemoteSource\"")
        private RemoteSource remoteSource ;
         
    }
    /**
     * Measurement quality flags. Bits 0-10 are defined for substation automation
     * in IEC 61850-7-3. Bits 11-15 are reserved for future expansion by that
     * document. Bits 16-31 are reserved for EMS applications.
     */
    @Entity
    @Table(name="\"MeasurementValueQuality\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MeasurementValueQuality
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A MeasurementValue has a MeasurementValueQuality associated with it.
         */
        public MeasurementValue getMeasurementValue () { return measurementValue; }
        public void setMeasurementValue ( MeasurementValue measurementValue ) { this.measurementValue = measurementValue; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"MeasurementValue\"")
        private MeasurementValue measurementValue ;
         
    }
    /**
     * The Name class provides the means to define any number of human readable
     * names for an object. A name is <b>not</b> to be used for defining inter-object
     * relationships. For inter-object relationships instead use the object identification
     * 'mRID'.
     */
    @Entity
    @Table(name="\"Name\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Name
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Any free text that name the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Identified object that this name designates.
         */
        public IdentifiedObject getIdentifiedObject () { return identifiedObject; }
        public void setIdentifiedObject ( IdentifiedObject identifiedObject ) { this.identifiedObject = identifiedObject; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"IdentifiedObject\"")
        private IdentifiedObject identifiedObject ;
         
        /**
         * Type of this name.
         */
        public NameType getNameType () { return nameType; }
        public void setNameType ( NameType nameType ) { this.nameType = nameType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"NameType\"")
        private NameType nameType ;
         
    }
    /**
     * Type of name. Possible values for attribute 'name' are implementation dependent
     * but standard profiles may specify types. An enterprise may have multiple
     * IT systems each having its own local name for the same object, e.g. a planning
     * system may have different names from an EMS. An object may also have different
     * names within the same IT system, e.g. localName as defined in CIM version
     * 14. The definition from CIM14 is:
     * The localName is a human readable name of the object. It is a free text
     * name local to a node in a naming hierarchy similar to a file directory
     * structure. A power system related naming hierarchy may be: Substation,
     * VoltageLevel, Equipment etc. Children of the same parent in such a hierarchy
     * have names that typically are unique among them.
     */
    @Entity
    @Table(name="\"NameType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class NameType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Description of the name type.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Name of the name type.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Authority responsible for managing names of this type.
         */
        public NameTypeAuthority getNameTypeAuthority () { return nameTypeAuthority; }
        public void setNameTypeAuthority ( NameTypeAuthority nameTypeAuthority ) { this.nameTypeAuthority = nameTypeAuthority; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"NameTypeAuthority\"")
        private NameTypeAuthority nameTypeAuthority ;
         
    }
    /**
     * Authority responsible for creation and management of names of a given type;
     * typically an organization or an enterprise system.
     */
    @Entity
    @Table(name="\"NameTypeAuthority\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class NameTypeAuthority
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Description of the name type authority.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Name of the name type authority.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * Document describing details of an active or planned outage in a part of
     * the electrical network.
     * A non-planned outage may be created upon:
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     * A planned outage may be created upon:
     * - a request for service, maintenance or construction work in the field,
     * or
     * - an operator-defined outage for what-if/contingency network analysis.
     */
    @Entity
    @Table(name="\"Outage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Outage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Free text comment.
         */
        public String getComment () { return comment; }
        public void setComment ( String comment ) { this.comment = comment; }
        @Basic()
        @Column(name="\"comment\"")
        private String comment ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * Document subject.
         */
        public String getSubject () { return subject; }
        public void setSubject ( String subject ) { this.subject = subject; }
        @Basic()
        @Column(name="\"subject\"")
        private String subject ;
         
        /**
         * Document title.
         */
        public String getTitle () { return title; }
        public void setTitle ( String title ) { this.title = title; }
        @Basic()
        @Column(name="\"title\"")
        private String title ;
         
        /**
         * Utility-specific classification of this document, according to its corporate
         * standards, practices, and existing IT systems (e.g., for management of
         * assets, maintenance, work, outage, customers, etc.).
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
    }
    /**
     * Set of spatial coordinates that determine a point, defined in the coordinate
     * system specified in 'Location.CoordinateSystem'. Use a single position
     * point instance to describe a point-oriented location. Use a sequence of
     * position points to describe a line-oriented object (physical location of
     * non-point oriented objects like cables or lines), or area of an object
     * (like a substation or a geographical zone - in this case, have first and
     * last position point with the same values).
     */
    @Entity
    @Table(name="\"PositionPoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PositionPoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Zero-relative sequence number of this point within a series of points.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
        /**
         * X axis position.
         */
        public String getXPosition () { return xPosition; }
        public void setXPosition ( String xPosition ) { this.xPosition = xPosition; }
        @Basic()
        @Column(name="\"xPosition\"")
        private String xPosition ;
         
        /**
         * Y axis position.
         */
        public String getYPosition () { return yPosition; }
        public void setYPosition ( String yPosition ) { this.yPosition = yPosition; }
        @Basic()
        @Column(name="\"yPosition\"")
        private String yPosition ;
         
    }
    /**
     * A power system resource (PSR) can be an item of equipment such as a switch,
     * an equipment container containing many individual items of equipment such
     * as a substation, or an organisational entity such as sub-control area.
     * Power system resources can have measurements associated.
     */
    @Entity
    @Table(name="\"PowerSystemResource\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerSystemResource
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * An electrical device consisting of two or more coupled windings, with or
     * without a magnetic core, for introducing mutual coupling between electric
     * circuits. Transformers can be used to control voltage and phase shift (active
     * power flow).
     * A power transformer may be composed of separate transformer tanks that
     * need not be identical.
     * A power transformer can be modelled with or without tanks and is intended
     * for use in both balanced and unbalanced representations. A power transformer
     * typically has two terminals, but may have one (grounding), three or more
     * terminals.
     * The inherited association ConductingEquipment.BaseVoltage should not be
     * used. The association from TransformerEnd to BaseVoltage should be used
     * instead.
     */
    @Entity
    @Table(name="\"PowerTransformer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerTransformer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The highest operating current (Ib in IEC 60909-0) before short circuit
         * (depends on network configuration and relevant reliability philosophy).
         * It is used for calculation of the impedance correction factor KT defined
         * in IEC 60909-0.
         */
        public Double getBeforeShCircuitHighestOperatingCurrent () { return beforeShCircuitHighestOperatingCurrent; }
        public void setBeforeShCircuitHighestOperatingCurrent ( Double beforeShCircuitHighestOperatingCurrent ) { this.beforeShCircuitHighestOperatingCurrent = beforeShCircuitHighestOperatingCurrent; }
        @Basic()
        @Column(name="\"beforeShCircuitHighestOperatingCurrent\"")
        private Double beforeShCircuitHighestOperatingCurrent ;
         
        /**
         * The highest operating voltage (Ub in IEC 60909-0) before short circuit.
         * It is used for calculation of the impedance correction factor KT defined
         * in IEC 60909-0. This is worst case voltage on the low side winding (3.7.1
         * of IEC 60909:2001). Used to define operating conditions.
         */
        public Double getBeforeShCircuitHighestOperatingVoltage () { return beforeShCircuitHighestOperatingVoltage; }
        public void setBeforeShCircuitHighestOperatingVoltage ( Double beforeShCircuitHighestOperatingVoltage ) { this.beforeShCircuitHighestOperatingVoltage = beforeShCircuitHighestOperatingVoltage; }
        @Basic()
        @Column(name="\"beforeShCircuitHighestOperatingVoltage\"")
        private Double beforeShCircuitHighestOperatingVoltage ;
         
        /**
         * The angle of power factor before short circuit (phib in IEC 60909-0). It
         * is used for calculation of the impedance correction factor KT defined in
         * IEC 60909-0. This is the worst case power factor. Used to define operating
         * conditions.
         */
        public Double getBeforeShortCircuitAnglePf () { return beforeShortCircuitAnglePf; }
        public void setBeforeShortCircuitAnglePf ( Double beforeShortCircuitAnglePf ) { this.beforeShortCircuitAnglePf = beforeShortCircuitAnglePf; }
        @Basic()
        @Column(name="\"beforeShortCircuitAnglePf\"")
        private Double beforeShortCircuitAnglePf ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The minimum operating voltage (uQmin in IEC 60909-0) at the high voltage
         * side (Q side) of the unit transformer of the power station unit. A value
         * well established from long-term operating experience of the system. It
         * is used for calculation of the impedance correction factor KG defined in
         * IEC 60909-0.
         */
        public Double getHighSideMinOperatingU () { return highSideMinOperatingU; }
        public void setHighSideMinOperatingU ( Double highSideMinOperatingU ) { this.highSideMinOperatingU = highSideMinOperatingU; }
        @Basic()
        @Column(name="\"highSideMinOperatingU\"")
        private Double highSideMinOperatingU ;
         
        /**
         * Indicates whether the machine is part of a power station unit. Used for
         * short circuit data exchange according to IEC 60909. It has an impact on
         * how the correction factors are calculated for transformers, since the transformer
         * is not necessarily part of a synchronous machine and generating unit. It
         * is not always possible to derive this information from the model. This
         * is why the attribute is necessary.
         */
        public Boolean getIsPartOfGeneratorUnit () { return isPartOfGeneratorUnit; }
        public void setIsPartOfGeneratorUnit ( Boolean isPartOfGeneratorUnit ) { this.isPartOfGeneratorUnit = isPartOfGeneratorUnit; }
        @Basic()
        @Column(name="\"isPartOfGeneratorUnit\"")
        private Boolean isPartOfGeneratorUnit ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * It is used to define if the data (other attributes related to short circuit
         * data exchange) defines long term operational conditions or not. Used for
         * short circuit data exchange according to IEC 60909.
         */
        public Boolean getOperationalValuesConsidered () { return operationalValuesConsidered; }
        public void setOperationalValuesConsidered ( Boolean operationalValuesConsidered ) { this.operationalValuesConsidered = operationalValuesConsidered; }
        @Basic()
        @Column(name="\"operationalValuesConsidered\"")
        private Boolean operationalValuesConsidered ;
         
        /**
         * Vector group of the transformer for protective relaying, e.g., Dyn1. For
         * unbalanced transformers, this may not be simply determined from the constituent
         * winding connections and phase angle displacements.
         * The vectorGroup string consists of the following components in the order
         * listed: high voltage winding connection, mid voltage winding connection
         * (for three winding transformers), phase displacement clock number from
         * 0 to 11, low voltage winding connection
         * phase displacement clock number from 0 to 11. The winding connections are
         * D (delta), Y (wye), YN (wye with neutral), Z (zigzag), ZN (zigzag with
         * neutral), A (auto transformer). Upper case means the high voltage, lower
         * case mid or low. The high voltage winding always has clock position 0 and
         * is not included in the vector group string. Some examples: YNy0 (two winding
         * wye to wye with no phase displacement), YNd11 (two winding wye to delta
         * with 330 degrees phase displacement), YNyn0d5 (three winding transformer
         * wye with neutral high voltage, wye with neutral mid voltage and no phase
         * displacement, delta low voltage with 150 degrees displacement).
         * Phase displacement is defined as the angular difference between the phasors
         * representing the voltages between the neutral point (real or imaginary)
         * and the corresponding terminals of two windings, a positive sequence voltage
         * system being applied to the high-voltage terminals, following each other
         * in alphabetical sequence if they are lettered, or in numerical sequence
         * if they are numbered: the phasors are assumed to rotate in a counter-clockwise
         * sense.
         */
        public String getVectorGroup () { return vectorGroup; }
        public void setVectorGroup ( String vectorGroup ) { this.vectorGroup = vectorGroup; }
        @Basic()
        @Column(name="\"vectorGroup\"")
        private String vectorGroup ;
         
        /**
         * Datasheet information for this power system resource.
         */
        public AssetInfo getAssetDatasheet () { return assetDatasheet; }
        public void setAssetDatasheet ( AssetInfo assetDatasheet ) { this.assetDatasheet = assetDatasheet; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AssetDatasheet\"")
        private AssetInfo assetDatasheet ;
         
        /**
         * Location of this power system resource.
         */
        public Location getLocation () { return location; }
        public void setLocation ( Location location ) { this.location = location; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Location\"")
        private Location location ;
         
    }
    /**
     * A PowerTransformerEnd is associated with each Terminal of a PowerTransformer.
     * The impedance values r, r0, x, and x0 of a PowerTransformerEnd represents
     * a star equivalent as follows.
     * 1) for a two Terminal PowerTransformer the high voltage (TransformerEnd.endNumber=1)
     * PowerTransformerEnd has non zero values on r, r0, x, and x0 while the low
     * voltage (TransformerEnd.endNumber=2) PowerTransformerEnd has zero values
     * for r, r0, x, and x0. Parameters are always provided, even if the PowerTransformerEnds
     * have the same rated voltage. In this case, the parameters are provided
     * at the PowerTransformerEnd which has TransformerEnd.endNumber equal to
     * 1.
     * 2) for a three Terminal PowerTransformer the three PowerTransformerEnds
     * represent a star equivalent with each leg in the star represented by r,
     * r0, x, and x0 values.
     * 3) For a three Terminal transformer each PowerTransformerEnd shall have
     * g, g0, b and b0 values corresponding to the no load losses distributed
     * on the three PowerTransformerEnds. The total no load loss shunt impedances
     * may also be placed at one of the PowerTransformerEnds, preferably the end
     * numbered 1, having the shunt values on end 1. This is the preferred way.
     * 4) for a PowerTransformer with more than three Terminals the PowerTransformerEnd
     * impedance values cannot be used. Instead use the TransformerMeshImpedance
     * or split the transformer into multiple PowerTransformers.
     * Each PowerTransformerEnd must be contained by a PowerTransformer. Because
     * a PowerTransformerEnd (or any other object) can not be contained by more
     * than one parent, a PowerTransformerEnd can not have an association to an
     * EquipmentContainer (Substation, VoltageLevel, etc).
     */
    @Entity
    @Table(name="\"PowerTransformerEnd\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerTransformerEnd
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Kind of connection.
         */
        public WindingConnection getConnectionKind () { return connectionKind; }
        public void setConnectionKind ( WindingConnection connectionKind ) { this.connectionKind = connectionKind; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"connectionKind\"")
        private WindingConnection connectionKind ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
    }
    /**
     * Set of power transformer data, from an equipment library.
     */
    @Entity
    @Table(name="\"PowerTransformerInfo\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PowerTransformerInfo extends AssetInfo
    {
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Asset information (nameplate) for this catalog asset type.
         */
        public CatalogAssetType getCatalogAssetType () { return catalogAssetType; }
        public void setCatalogAssetType ( CatalogAssetType catalogAssetType ) { this.catalogAssetType = catalogAssetType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CatalogAssetType\"")
        private CatalogAssetType catalogAssetType ;
         
        /**
         * Product asset model which conforms to this catalog asset type.
         */
        public ProductAssetModel getProductAssetModel () { return productAssetModel; }
        public void setProductAssetModel ( ProductAssetModel productAssetModel ) { this.productAssetModel = productAssetModel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ProductAssetModel\"")
        private ProductAssetModel productAssetModel ;
         
    }
    /**
     * Documented procedure for various types of work or work tasks on assets.
     */
    @Entity
    @Table(name="\"Procedure\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Procedure
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Textual description of this procedure.
         */
        public String getInstruction () { return instruction; }
        public void setInstruction ( String instruction ) { this.instruction = instruction; }
        @Basic()
        @Column(name="\"instruction\"")
        private String instruction ;
         
        /**
         * Kind of procedure.
         */
        public String getKind () { return kind; }
        public void setKind ( String kind ) { this.kind = kind; }
        @Basic()
        @Column(name="\"kind\"")
        private String kind ;
         
        /**
         * Sequence number in a sequence of procedures being performed.
         */
        public String getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( String sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private String sequenceNumber ;
         
    }
    /**
     * A data set recorded each time a procedure is executed. Observed results
     * are captured in associated measurement values and/or values for properties
     * relevant to the type of procedure performed.
     */
    @Entity
    @Table(name="\"ProcedureDataSet\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ProcedureDataSet
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Date and time procedure was completed.
         */
        public String getCompletedDateTime () { return completedDateTime; }
        public void setCompletedDateTime ( String completedDateTime ) { this.completedDateTime = completedDateTime; }
        @Basic()
        @Column(name="\"completedDateTime\"")
        private String completedDateTime ;
         
    }
     
    /**
     * Kind of procedure.
     */
    @Entity
    @Table(name="\"ProcedureKind\"")
    public static class ProcedureKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Asset model by a specific manufacturer.
     */
    @Entity
    @Table(name="\"ProductAssetModel\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ProductAssetModel
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Catalogue number for asset model.
         */
        public String getCatalogueNumber () { return catalogueNumber; }
        public void setCatalogueNumber ( String catalogueNumber ) { this.catalogueNumber = catalogueNumber; }
        @Basic()
        @Column(name="\"catalogueNumber\"")
        private String catalogueNumber ;
         
        /**
         * Kind of corporate standard for this asset model.
         */
        public String getCorporateStandardKind () { return corporateStandardKind; }
        public void setCorporateStandardKind ( String corporateStandardKind ) { this.corporateStandardKind = corporateStandardKind; }
        @Basic()
        @Column(name="\"corporateStandardKind\"")
        private String corporateStandardKind ;
         
        /**
         * Drawing number for asset model.
         */
        public String getDrawingNumber () { return drawingNumber; }
        public void setDrawingNumber ( String drawingNumber ) { this.drawingNumber = drawingNumber; }
        @Basic()
        @Column(name="\"drawingNumber\"")
        private String drawingNumber ;
         
        /**
         * Manufacturer's model number.
         */
        public String getModelNumber () { return modelNumber; }
        public void setModelNumber ( String modelNumber ) { this.modelNumber = modelNumber; }
        @Basic()
        @Column(name="\"modelNumber\"")
        private String modelNumber ;
         
        /**
         * Version number for product model, which indicates vintage of the product.
         */
        public String getModelVersion () { return modelVersion; }
        public void setModelVersion ( String modelVersion ) { this.modelVersion = modelVersion; }
        @Basic()
        @Column(name="\"modelVersion\"")
        private String modelVersion ;
         
    }
    /**
     * Remote sources are state variables that are telemetered or calculated within
     * the remote unit.
     */
    @Entity
    @Table(name="\"RemoteSource\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RemoteSource
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The smallest change in value to be reported.
         */
        public Double getDeadband () { return deadband; }
        public void setDeadband ( Double deadband ) { this.deadband = deadband; }
        @Basic()
        @Column(name="\"deadband\"")
        private Double deadband ;
         
        /**
         * The time interval between scans.
         */
        public Double getScanInterval () { return scanInterval; }
        public void setScanInterval ( Double scanInterval ) { this.scanInterval = scanInterval; }
        @Basic()
        @Column(name="\"scanInterval\"")
        private Double scanInterval ;
         
        /**
         * The maximum value the telemetry item can return.
         */
        public Double getSensorMaximum () { return sensorMaximum; }
        public void setSensorMaximum ( Double sensorMaximum ) { this.sensorMaximum = sensorMaximum; }
        @Basic()
        @Column(name="\"sensorMaximum\"")
        private Double sensorMaximum ;
         
        /**
         * The minimum value the telemetry item can return.
         */
        public Double getSensorMinimum () { return sensorMinimum; }
        public void setSensorMinimum ( Double sensorMinimum ) { this.sensorMinimum = sensorMinimum; }
        @Basic()
        @Column(name="\"sensorMinimum\"")
        private Double sensorMinimum ;
         
    }
     
    /**
     * Reason asset retired.
     */
    @Entity
    @Table(name="\"RetiredReasonKind\"")
    public static class RetiredReasonKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Kinds of scaling.
     */
    @Entity
    @Table(name="\"ScaleKind\"")
    public static class ScaleKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Classifications of network roles in which transformers can be deployed.
     * The classifications are intended to reflect both criticality of transformer
     * in network operations and typical usage experienced by transformer.
     * Note: This enumeration provides essential information to asset health analytics.
     * The existing list is a starting point and is anticipated to be fleshed
     * out further as requirements are better understood (PAB 2016/01/09).
     */
    @Entity
    @Table(name="\"TransformerApplicationKind\"")
    public static class TransformerApplicationKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Set of transformer tank data, from an equipment library.
     */
    @Entity
    @Table(name="\"TransformerTankInfo\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class TransformerTankInfo extends AssetInfo
    {
        /**
         * The aliasName is free text human readable name of the object alternative
         * to IdentifiedObject.name. It may be non unique and may not correlate to
         * a naming hierarchy.
         * The attribute aliasName is retained because of backwards compatibility
         * between CIM relases. It is however recommended to replace aliasName with
         * the Name class as aliasName is planned for retirement at a future time.
         */
        public String getAliasName () { return aliasName; }
        public void setAliasName ( String aliasName ) { this.aliasName = aliasName; }
        @Basic()
        @Column(name="\"aliasName\"")
        private String aliasName ;
         
        /**
         * The description is a free human readable text describing or naming the
         * object. It may be non unique and may not correlate to a naming hierarchy.
         */
        public String getDescription () { return description; }
        public void setDescription ( String description ) { this.description = description; }
        @Basic()
        @Column(name="\"description\"")
        private String description ;
         
        /**
         * The name is any free human readable and possibly non unique text naming
         * the object.
         */
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Basic()
        @Column(name="\"name\"")
        private String name ;
         
        /**
         * Product asset model which conforms to this catalog asset type.
         */
        public ProductAssetModel getProductAssetModel () { return productAssetModel; }
        public void setProductAssetModel ( ProductAssetModel productAssetModel ) { this.productAssetModel = productAssetModel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ProductAssetModel\"")
        private ProductAssetModel productAssetModel ;
         
    }
     
    /**
     * The unit multipliers defined for the CIM. When applied to unit symbols,
     * the unit symbol is treated as a derived unit. Regardless of the contents
     * of the unit symbol text, the unit symbol shall be treated as if it were
     * a single-character unit symbol. Unit symbols should not contain multipliers,
     * and it should be left to the multiplier to define the multiple for an entire
     * data type.
     * For example, if a unit symbol is "m2Pers" and the multiplier is "k", then
     * the value is k(m**2/s), and the multiplier applies to the entire final
     * value, not to any individual part of the value. This can be conceptualized
     * by substituting a derived unit symbol for the unit type. If one imagines
     * that the symbol "" represents the derived unit "m2Pers", then applying
     * the multiplier "k" can be conceptualized simply as "k".
     * For example, the SI unit for mass is "kg" and not "g". If the unit symbol
     * is defined as "kg", then the multiplier is applied to "kg" as a whole and
     * does not replace the "k" in front of the "g". In this case, the multiplier
     * of "m" would be used with the unit symbol of "kg" to represent one gram.
     * As a text string, this violates the instructions in IEC 80000-1. However,
     * because the unit symbol in CIM is treated as a derived unit instead of
     * as an SI unit, it makes more sense to conceptualize the "kg" as if it were
     * replaced by one of the proposed replacements for the SI mass symbol. If
     * one imagines that the "kg" were replaced by a symbol "", then it is easier
     * to conceptualize the multiplier "m" as creating the proper unit "m", and
     * not the forbidden unit "mkg".
     */
    @Entity
    @Table(name="\"UnitMultiplier\"")
    public static class UnitMultiplier
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The derived units defined for usage in the CIM. In some cases, the derived
     * unit is equal to an SI unit. Whenever possible, the standard derived symbol
     * is used instead of the formula for the derived unit. For example, the unit
     * symbol Farad is defined as "F" instead of "CPerV". In cases where a standard
     * symbol does not exist for a derived unit, the formula for the unit is used
     * as the unit symbol. For example, density does not have a standard symbol
     * and so it is represented as "kgPerm3". With the exception of the "kg",
     * which is an SI unit, the unit symbols do not contain multipliers and therefore
     * represent the base derived unit to which a multiplier can be applied as
     * a whole.
     * Every unit symbol is treated as an unparseable text as if it were a single-letter
     * symbol. The meaning of each unit symbol is defined by the accompanying
     * descriptive text and not by the text contents of the unit symbol.
     * To allow the widest possible range of serializations without requiring
     * special character handling, several substitutions are made which deviate
     * from the format described in IEC 80000-1. The division symbol "/" is replaced
     * by the letters "Per". Exponents are written in plain text after the unit
     * as "m3" instead of being formatted as "m" with a superscript of 3 or introducing
     * a symbol as in "m^3". The degree symbol "" is replaced with the letters
     * "deg". Any clarification of the meaning for a substitution is included
     * in the description for the unit symbol.
     * Non-SI units are included in list of unit symbols to allow sources of data
     * to be correctly labelled with their non-SI units (for example, a GPS sensor
     * that is reporting numbers that represent feet instead of meters). This
     * allows software to use the unit symbol information correctly convert and
     * scale the raw data of those sources into SI-based units.
     * The integer values are used for harmonization with IEC 61850.
     */
    @Entity
    @Table(name="\"UnitSymbol\"")
    public static class UnitSymbol
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    public static final Class[] allClasses = new Class[]
    {
        ActivityRecord.class,
        Analytic.class,
        AnalyticKind.class,
        AnalyticScore.class,
        Asset.class,
        AssetContainer.class,
        AssetDeployment.class,
        AssetInfo.class,
        AssetKind.class,
        AssetLifecycleStateKind.class,
        CatalogAssetType.class,
        CoordinateSystem.class,
        CorporateStandardKind.class,
        DeploymentStateKind.class,
        FacilityKind.class,
        InUseStateKind.class,
        Location.class,
        Measurement.class,
        MeasurementAction.class,
        MeasurementValue.class,
        MeasurementValueQuality.class,
        Name.class,
        NameType.class,
        NameTypeAuthority.class,
        Outage.class,
        PositionPoint.class,
        PowerSystemResource.class,
        PowerTransformer.class,
        PowerTransformerEnd.class,
        PowerTransformerInfo.class,
        Procedure.class,
        ProcedureDataSet.class,
        ProcedureKind.class,
        ProductAssetModel.class,
        RemoteSource.class,
        RetiredReasonKind.class,
        ScaleKind.class,
        TransformerApplicationKind.class,
        TransformerTankInfo.class,
        UnitMultiplier.class,
        UnitSymbol.class
    };
}
